{"componentChunkName":"component---src-templates-post-jsx","path":"/adder-accumulator/","result":{"data":{"site":{"siteMetadata":{"title":"Dev.HJ"}},"markdownRemark":{"id":"e7ea69fe-b48d-530a-9cb3-6cb7afeb7f67","excerpt":"LongAdder와 LongAccumulator 이전 포스팅에서는 Atomic Type에 대하여 알아보았다. -> Atomic Type에 대하여 Atomic 클래스는 원자성을 보장하고 CAS 알고리즘으로 구현되어있다. 쓰레드 간의 경쟁(Race condition)이 심한 경우 CPU 소모가 크겠지만 Lock을 사용하는 것 보단 성능적 측면에서 우위에 있을…","html":"<h2>LongAdder와 LongAccumulator</h2>\n<p>이전 포스팅에서는 Atomic Type에 대하여 알아보았다. -> <a href=\"https://hojoon7807.github.io/atomic/\">Atomic Type에 대하여</a></p>\n<p>Atomic 클래스는 원자성을 보장하고 CAS 알고리즘으로 구현되어있다. 쓰레드 간의 경쟁(Race condition)이 심한 경우 CPU 소모가 크겠지만 Lock을 사용하는 것 보단 성능적 측면에서 우위에 있을 것이다.</p>\n<p>LongAdder와 LongAccumulator은 AtomicLong에서 사용하는 CAS 연산에 의한 경합 과정에서 CPU 소모를 줄이기 위해 고안되었다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/de53174d6db3e18780f896db7aa53f35/248ed/adder.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 41.1764705882353%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABP0lEQVQoz2VSAY6CQAzk/18zMTHqGUXUCIgCSwIssMAuc2097vRssmyZTiedgldVJVRRYBgGjOOIgvKyqmCtRdt1yPMcTdNAaw2lCvR9L1zm1bWWHq4rpdAR33POYSBQN60U27YlIUPY8MRImDl8OmOkxmFIWJMQB/fVuoEjroefYFHrJkyUW3qM1hHR4jW4gYW4xg4601PPMzf9IBxvmkhkmuSFR79cI4RxIrbmYDy8XhFFMcIwRBTHuCV3sZ3cH8iyDLdbAt/3nxPOgryHxWKB1Wol1ucoyxLb7Ra73U7u5XKJzWZD+RfW6zWOQYDDwZfeN0G+eR9s/xVnSzwlL72mj5OmKU6nM4500lzJx5Hd0/nd4V+zk13O2Iz/j0eWoyjrD/xtwop+l/1+jyA4wRjzJvoqXtEK2OL5cvngfQO2FGndJm0w2gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='adder' title='adder' src='/static/de53174d6db3e18780f896db7aa53f35/ca1dc/adder.png' srcset='/static/de53174d6db3e18780f896db7aa53f35/e7570/adder.png 170w,\n/static/de53174d6db3e18780f896db7aa53f35/f46e7/adder.png 340w,\n/static/de53174d6db3e18780f896db7aa53f35/ca1dc/adder.png 680w,\n/static/de53174d6db3e18780f896db7aa53f35/02d09/adder.png 1020w,\n/static/de53174d6db3e18780f896db7aa53f35/248ed/adder.png 1268w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>AtomicLong일 경우 위의 그림에서 볼 수 있듯이, 단일 volatile 변수를 공유하기 때문에, CAS를 사용한 반복적인 메모리 읽기 작업과 비교 연산 수행 과정에서 CPU를 많이 소모하게 되고 경합과정이 일어나게 된다.</p>\n<p>하지만 LongAdder와 LongAccumulator는 이 문제점을 해결하기 위해 공용 메모리인 <strong>base</strong>와 쓰레드 별 메모리인 <strong>cell</strong>로 나누어 설계되어있다. base 변수를 CAS 방식으로 읽다가 업데이트가 실패하면 while문을 도는 것 대신 쓰레드 별로 cell 메모리에 별도의 연산을 수행한다.</p>\n<p>이러한 개념을 <strong>Dynamic Striping</strong>이라고 하며 이를 구현한 Striped64 클래스를 LongAdder와 LongAccumulator가 상속받는다.</p>\n<h2>CPU Cache의 False sharing 최소화</h2>\n<p>ongAdder와 LongAccumulator는 cell이라고 하는 여러 개의 개별 변수를 갖고 있는데, 이 변수들은 일반적으로 메모리상에 근접해 있다. 이러한 데이터들은 CPU Cache상에 존재할 가능성이 높고 CPU에서는 캐시 일관성(cache coherence)이라는 메커니즘이 존재한다. 만약 한 쓰레드가 자신의 cell value를 변경할 경우 일관성을 유지하기 위해 다른 쓰레드의 CPU Cache도 계속 업데이트 해야하는 false sharing이 발생할 가능성이 높다.</p>\n<p>false sharing을 더 자세히 설명하면 다음과 같다.</p>\n<blockquote>\n<p>False Sharing은 보통 cache coherency protocol에 의해 발생한다. cache는 보통 word 단위가 아닌 block 단위로 데이터를 가져오는데 이것을 cache line이라고 한다.<br>\ncache line은 보통 64바이트, 128바이트 단위로 모든 작업이 이루어진다. 만약 thread 0에서 사용하는 데이터는 block의 첫 번째 4바이트 뿐이고, thread 1에서도 사용하는 데이터는 마지막 4바이트라고 가정하면 이 둘은 실제 공유하는 데이터가 없지만 같은 cache line에 있기 때문에 어느 한 코어가 데이터에 접근할 때 마다 CPU는 cache가 공유되는 것으로 착각한다.<br>\n그래서 서로를 invalid 시키는 현상이 일어나게 되고, cache miss를 겪게 된다. 따라서 false sharing은 성능 하락으로 이어질 수 있다.</p>\n</blockquote>\n<p>그래서 이를 해결하기 위해 Striped64 클래스는 cell의 value가 Cache line의 크기가 되도록 padding을 붙이게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@jdk.internal.vm.annotation.Contended</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Cell</span> <span class=\"token punctuation\">{</span></code></pre></div>\n<p>Striped64 클래스의 내부클래스 Cell에 있는 Contended 어노테이션이 padding을 추가하는 역할을 한다.</p>\n<h2>차이점</h2>\n<p>Oracle Java 17 API 문서에서는 각 클래스를 다음과 같이 설명하고 있다.</p>\n<h3>LongAdder</h3>\n<p>LongAdder클래스는 일반적으로 세분화된 동기화 제어가 아닌 통계 수집과 같은 일반적인 합계를 업데이트할 때 AtomicLong보다 선호된다. 낮은 경합에서는 두 클래스가 비슷한 특성을 가지지만 더 많은 경합에서 예상 처리량은 훨씬 높다.<br>\n이 클래스는 Number 클래스를 상속 받았고, 객체가 계속 변할 것이라 예상해 equals, hashcode, compareTo 메서드를 정의하지 않았다. 그래서 컬렉션의 key로 유용하지 않다.</p>\n<h3>LongAccumulator</h3>\n<p>스레드 내 또는 스레드 간의 누적 순서는 보장되지 않으며 의존할 수 없으므로 LongAccumulator 클래스는 누적 순서가 중요하지 않은 함수에만 적용할 수 있다. 제공된 accumulator function은 스레드 간의 경합으로 인해 업데이트 시도가 실패할 때 다시 적용될 수 있으므로 부작용이 없어야 한다. 함수는 기존 값을 하나의 인자로 적용하고 주어진 업데이트를 다른 인자로 적용한다. 예를 들어 최대값을 유지하려면 Long.MIN_VALUE와 함께 Long::max를 함수에 제공 함으로 구현할 수 있다.</p>\n<p>마찬가지로 Number 클래스를 상속 받았고, 객체가 계속 변할 것이라 예상해 equals, hashcode, compareTo 메서드를 정의하지 않았다. 그래서 컬렉션의 key로 유용하지 않다.</p>\n<p><code class=\"language-text\">new LongAdder()</code>는 <code class=\"language-text\">new LongAccumulator((x, y) -> x + y, 0L)</code>과 같다고 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">LongAccumulator</span> acc <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LongAccumulator</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span><span class=\"token operator\">::</span><span class=\"token function\">sum</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nacc<span class=\"token punctuation\">.</span><span class=\"token function\">accumulate</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>accumulate(10) 메소드를 호출하면 a[0]에 인자로 받은 10과 생성자의 두번째 인자로 받은 초기값 0이 합쳐져 10+0의 결과가 a[0]에 들어가고,<br>\n계속 accumulate 메소드를 호출할수록 a[n]번째에 이처럼 인자+초기값의 결과가 누적된다.</p>\n<h2>AtomicLong과 LongAdder 성능 차이</h2>\n<h3>업데이트 성능</h3>\n<p align='center'>\n<span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 480px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/8e715f07403ef810c442dc6a5b15b18c/9aebd/write.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACeUlEQVQoz01TaXOiQBT03yQxJuXJYZRDERSB4R4gWbPZlMTS2uzW/v+q3vfIHvkwzDC8abr79fSur6/R7/dxf3+PxWKJIAjgui4iIZAkCbIsQ1mWKIoCafqxjuMYHtXYqxUsy+rOMgZj9fhxSy+TyQRxkqI9thAiwrfXV5zPZ7Rti/PlgtPphGP7hh/v7zS3qKREXpR4+XrAdDrpAG9ubtCbTqcwjCV41jSNWC6wXq+x3W6x3+8RRRH9QHSseOY9z/PgOA4WSwMTRYWqKJhNxujf3qKnqioBrKDQB8MwsNls4Pt+d5jlstS/kosip70UYSSoZo8mDVHtTGTOHO7KxGBwhx6zYkY8sx/sH/vI/uV53oFJkldVslunhUSdJ2hTB43wsHVsPOgqhqMx7u4IUCG6zErXddi23UkNw5AakHas2Ku6rlDIGpIAL08p3g8Z0nCPtevBtGzo83nnYwc4m82wdtafAD3yLUT2B7AoJWRV4/TyhF/PCZ7zEIKaF4RRV8tn5gTITe0AebEiD1myaZjY0F+3uz2CKIbkLjYS35uImGVo6hpJViCJE4RBCHfjwjIt6JqO8Xj8H5A95OY4GwfBboXjY4zLIcGx9PDz2KCRlEdZIi8zZORfmiXwgx28nQvTNjBfaGClg8EAPUbm7k6nMyokVvECdeWjfqSIJC7kQSIsfDTPJbJaIMp9VF8KbPYWRBHAdB+wdHRSaX/kkB+MPBwOocwUMnhJRq/gU7cFyUrIr0QkELGguJB/ZEVI/lmm3Q1V0TAajjEajT5uytXV1b+rx/I1Te3CnblLSLEj1jlyGtuA8kkx4SgJCjvXKKqCMQX689X7Da7RtUU4otxqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='write' title='write' src='/static/8e715f07403ef810c442dc6a5b15b18c/9aebd/write.png' srcset='/static/8e715f07403ef810c442dc6a5b15b18c/e7570/write.png 170w,\n/static/8e715f07403ef810c442dc6a5b15b18c/f46e7/write.png 340w,\n/static/8e715f07403ef810c442dc6a5b15b18c/9aebd/write.png 480w' sizes='(max-width: 480px) 100vw, 480px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>AtomicLong의 경우 쓰레드의 개수 증가할수록 성능 하락이 큰폭으로 증가한다. 반면 LongAdder는 쓰레드 개수와 비교해 실행 시간이 증가하지만 총 실행시간 자체가 상대적으로 매우 짧다.</p>\n<h3>읽기 성능</h3>\n<p align='center'>\n<span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 480px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/088121ea4f58edaf7f67830ec9281b6d/9aebd/read.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACWklEQVQoz01T2XaqQBD0b5KoMcZoBAHXgKCyDZsikGPcYsz/v1a6x5t78jAHGKarq6pravf392g0Gnh8fMTLywum0ymCIIDjOBBCIIoixHGMNE3lU4QCq9UKb6YFyzSppoNWq4V6vY67uzvUfgHb7TZUVUW2XuNyuVBhiNPphOv1ivP5jK+vCz4/L3Kv2G7pXI7T8QBd12QtE3p4eEBNURQMBgN0Oh1omobhcIjJZALbtiUT13Xh+z48z5OLmVuWJZXouo5+vy9rm82mZFkzDAPj8Ri9Xg+j0QgmyVgulxKE5SZJIuXmeY6yLHE4HFAUhXz//b9YLGQdg9aYFQNxJ2Y2n88ls5Ak82H2jcGu39+oqgprsoT32V9uzOe5nu1i2TWmzQz/ArI0HgyD7XY7HI9HZFn2fzDcjJuydAZj21i2BGTJDMSbM/Ll17stGX/Y76XEsiyw2awlOwaNIiGb8ln2UtMG6Ha7N0CNGHIX9lA3hjIOUZygrN7lxENBPqXMLkNMYCKK4QchFiT3jRgawxFeFRXt52cCbN4kM+BgoCH0Vviotti/F0gCF3kaodxkqDYpqnyNIouxzRJkwkcceHBtE445w8RQoanKbShsJi+d4pIHDkrfQhXM8ZG6OND63Aqc1h6+qgSndIUzfe+EjX3mI1+OkXsmxLQPZzZEvdG8BZuROZzd3isUjRhPZljYPG2KTxjBJYkBSXf9kL4F7MUKszcLqm6gr2potTt4onoZbAbkQPL14Wuk0LTZhtjSkfmO9CymIfg0BM4dr8D3oFPclH+hfvpz9X4A11O3iRkEMHgAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='read' title='read' src='/static/088121ea4f58edaf7f67830ec9281b6d/9aebd/read.png' srcset='/static/088121ea4f58edaf7f67830ec9281b6d/e7570/read.png 170w,\n/static/088121ea4f58edaf7f67830ec9281b6d/f46e7/read.png 340w,\n/static/088121ea4f58edaf7f67830ec9281b6d/9aebd/read.png 480w' sizes='(max-width: 480px) 100vw, 480px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>AtomicLong은 내부에 단일 멤버 변수 하나를 사용하기 쓰레드 개수에 상관없이 읽기 시간이 비등하지만, LongAdder의 경우 쓰레드가 늘어날수록 읽을 때 합산해야하는 값의 개수가 증가하므로 실행시간이 증가한다.</p>\n<p>경우에 따라 읽기 작업을 많이 수행하는 상황이면 Atomic 클래스를 사용하고, 쓰기 작업을 많이 수행하는 상황이면 adder나 accumulator를 사용하면될 것 같다.</p>","frontmatter":{"title":"Java - LongAdder와 LongAccumulator","date":"March 04, 2022","update":"March 04, 2022","tags":["java"],"series":null},"fields":{"slug":"/adder-accumulator/","readingTime":{"minutes":7.79}}},"seriesList":{"edges":[{"node":{"id":"aeeabe20-f428-571f-a085-6cb528323517","fields":{"slug":"/jvm/"},"frontmatter":{"title":"Java Virtaul Machine"}}},{"node":{"id":"d322ca1f-aa27-5fc4-8ceb-7982c5738663","fields":{"slug":"/hashing/"},"frontmatter":{"title":"해싱이란?"}}},{"node":{"id":"85f7d472-c933-5918-9df5-33510bbd5c40","fields":{"slug":"/primitive-type/"},"frontmatter":{"title":"기본 타입(primitive type)"}}},{"node":{"id":"bbbb67ac-6c95-5684-b034-0f5e0ddc8ca1","fields":{"slug":"/equals/"},"frontmatter":{"title":"equals와 =="}}},{"node":{"id":"9c040466-1d6f-5b3f-b1e2-b611a0920f53","fields":{"slug":"/stringPool/"},"frontmatter":{"title":"String Pool"}}},{"node":{"id":"e9ec703f-3d62-523a-b7c7-f121c47bbf9f","fields":{"slug":"/string/"},"frontmatter":{"title":"문자열 중복 "}}},{"node":{"id":"c8e0cf33-615a-59be-bc1e-e26c406c927d","fields":{"slug":"/hashmap/"},"frontmatter":{"title":"HashMap"}}},{"node":{"id":"4e14a9fa-fa01-5cbc-9153-9bc68655ca17","fields":{"slug":"/generic/"},"frontmatter":{"title":"제너릭(Generic)"}}},{"node":{"id":"7c769d15-9003-56b7-9fc5-b1b960da36c0","fields":{"slug":"/process/"},"frontmatter":{"title":"[운영체제(OS)] 1.프로세스"}}},{"node":{"id":"4da2182b-2793-5418-a407-01f29fbbd757","fields":{"slug":"/map/"},"frontmatter":{"title":"HashMap, HashTable, ConcurrentHashMap"}}},{"node":{"id":"15a49153-8fff-5ab6-953e-5215b8e2faec","fields":{"slug":"/process2/"},"frontmatter":{"title":"[운영체제(OS)] 2.프로세스-IPC"}}},{"node":{"id":"0e33327d-d671-5b12-aa17-919f5b7107bd","fields":{"slug":"/thread/"},"frontmatter":{"title":"[운영체제(OS)] 3. 쓰레드(Thread)"}}},{"node":{"id":"794b97e8-63d4-5ed3-b203-d391651ec308","fields":{"slug":"/atomic/"},"frontmatter":{"title":"Java - Atomic"}}},{"node":{"id":"e7ea69fe-b48d-530a-9cb3-6cb7afeb7f67","fields":{"slug":"/adder-accumulator/"},"frontmatter":{"title":"Java - LongAdder와 LongAccumulator"}}},{"node":{"id":"678a2cb4-6b30-5113-9297-704160fe3a46","fields":{"slug":"/lambda/"},"frontmatter":{"title":"Java - 람다와 함수형 인터페이스"}}},{"node":{"id":"ea516931-cf7d-5fe6-a5e2-43145feed0e7","fields":{"slug":"/var/"},"frontmatter":{"title":"Java - var"}}},{"node":{"id":"03eac536-09bf-5d35-9903-1e5eff2c7123","fields":{"slug":"/fetch/"},"frontmatter":{"title":"JPA - 즉시로딩과 지연로딩"}}},{"node":{"id":"97f1315c-697a-52a2-ae72-77e3cb4869ec","fields":{"slug":"/content-type/"},"frontmatter":{"title":"[토이 프로젝트] - Content-Type - application/json"}}}]},"previous":{"fields":{"slug":"/atomic/"},"frontmatter":{"title":"Java - Atomic"}},"next":{"fields":{"slug":"/concurrency/"},"frontmatter":{"title":"Effective Java - 동시성(Item 78)"}}},"pageContext":{"id":"e7ea69fe-b48d-530a-9cb3-6cb7afeb7f67","series":null,"previousPostId":"794b97e8-63d4-5ed3-b203-d391651ec308","nextPostId":"006c5ce2-47fa-57a8-ab4b-4b66805bf0d3"}},"staticQueryHashes":[]}