{"componentChunkName":"component---src-templates-post-jsx","path":"/jvm/","result":{"data":{"site":{"siteMetadata":{"title":"Dev.HJ"}},"markdownRemark":{"id":"aeeabe20-f428-571f-a085-6cb528323517","excerpt":"Java Virtaul Machine JVM JVM Java Virtual Machine 자바 가상 머신을 약자로 줄여놓은 용어이다. 가상머신이란 프로그램을 실행시키기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것이라고 할 수 있다. JVM은 자바 어플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행시키는 역할을 한다. JVM의 특징…","html":"<h1>Java Virtaul Machine</h1>\n<h2>JVM</h2>\n<p>JVM Java Virtual Machine 자바 가상 머신을 약자로 줄여놓은 용어이다. 가상머신이란 프로그램을 실행시키기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것이라고 할 수 있다. JVM은 자바 어플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행시키는 역할을 한다.</p>\n<p>JVM의 특징</p>\n<ul>\n<li><strong>스택 기반의 가상 머신</strong>: 대표적인 컴퓨터 아키텍처인 인텔이나 ARM 아키텍처 같은 하드웨어는 레지스터 기반으로 동작하지만 JVM은 스택 기반으로 동작한다.</li>\n<li><strong>심볼릭 레퍼런스</strong>: 기본 자료형을 제외한 모든 타입을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심복릭 레퍼런스를 통해 참조한다.</li>\n<li><strong>가비지 컬렉션(Garbage Collection)</strong>: 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.</li>\n<li><strong>기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장</strong>: C/C++ 등의 언어는 플랫폼에 따라 int형의 크기가 변한다. JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.</li>\n<li><strong>네트워크 바이트 오더</strong>: 자바 클래스 파일은 네트워크 바이트 오더를 사용한다. 인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크 바이트 오더를 사용한다. 네트워크 바이트 오더는 빅 엔디안이다.</li>\n</ul>\n<h3>스택 기반과 레지스터 기반의 차이</h3>\n<p>가장 큰 차이는 피연산자를 저장하고 다시 가져오는 메카니즘이 다르다.</p>\n<h3>Stack 기반 가상 머신</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/933c57e8593b0c79a3083bdcf3e4fd1a/78d47/stack.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 43.529411764705884%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABRUlEQVQoz6WSTW6DMBCFc9feoMfoHXqH3iDLKuEnWVQKTZBowiKkKRjzj7F5xdOY0LSLSh1pNMCMv+E9mOESfd9TlVKibVs0TUNVCAHRCSgl8VvoeSHakTG7BdZ1jSzLwBhDURRIEoa6/DqgpBoX6aqUotk0Zd+B+sIAq6pCnufIixx11SDJzgjOL/DfXfCcEYDz9AJKcTpFtHwEGpgB6q1aZlkWdO9HKzw83eHx+R68+kAnJKkw81pulvGfkk3sdjs4jkO5Xq8RhiFkL8CLBJ7nwbaHnuvCdR1EUURqEpZcgdpU44t+4L3qQ9YAW1Hd798GiVoex2azGRbZ1LMsC4fwMHgco6zKK/B4PFLT9338J4wFsyAIMJ/Psd1uyVwtmXM+/hJTj7W/07z1n95Qe7RYLLBcLgeJNuI4Rtd1mH79v6SZ/wSMFbLo/yMxPQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='stack' title='stack' src='/static/933c57e8593b0c79a3083bdcf3e4fd1a/ca1dc/stack.png' srcset='/static/933c57e8593b0c79a3083bdcf3e4fd1a/e7570/stack.png 170w,\n/static/933c57e8593b0c79a3083bdcf3e4fd1a/f46e7/stack.png 340w,\n/static/933c57e8593b0c79a3083bdcf3e4fd1a/ca1dc/stack.png 680w,\n/static/933c57e8593b0c79a3083bdcf3e4fd1a/78d47/stack.png 800w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>Java VM, Net Clr</li>\n<li>대다수의 가상머신이 스택기반</li>\n<li>피연산자와 연산 후 결과를 스택에 저장한다.</li>\n<li>위의 경우 스택 구조이기 때문에 Push, Pop이 필요하며 4단계의 명령이 필요하다.</li>\n<li>장점: 다음 피연산자의 메모리 위치를 기억할 필요가 없다. 스택에서 pop만 하면 피연산자가 나오기 때문에 메모리를 기억할 필요가 없다.</li>\n</ul>\n<h3>Register 기반 가상 머신</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/b7390035decf56fcfa637b2315e26f27/78d47/register.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 51.764705882352935%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACHElEQVQoz12S63LSUBRG+5K+gy/iI/hPhzotFLCEO7TQkhshBIqGtqPSFgjXABKkEAj3z50gjnhmMjtzsrLy7Z1zstvtYK/Rq4mwpEG87yP7pYHiYxfKdwMBoQb959hhbHa1XiMu15Au6ZDVFvLlNkoVA372BXm1gpODcDxZIpFXCL5E+i6KuMQgpQSQVAroG3Mc1mYDpAplxHIMSYmjel1gKEwGxYfqsTCWkxHizxGVPiOQcSOW9SAmy+gN98LF0qJrjWtFRZCnZzk/cR5EiWOEFAr3R8IVARIJT5GQfWDYMyQFF6UsQtUe8P72Ld5F3qDc5cDd/UCAszkvgtwZQsInEl4dC39RwjglDAseajtAQi+BbrpXoPUG0IYqyk0Wg0kXN8VHSnjhjIfhvEiIF8Sm/09oC/P0wAYZ+rIfYdHrjGEwWvyd4XYLavkrdeJzPhzk/UhmffTezfEMR69LRCQRQeEDzc1NLbkQEj8ikhPRM6w/uh02JEzmS2B4F3HnlPDU4S75OJTyP8KZtUaawCvpFimZozbsmqGrhLY+hGXNMZuZmExNsPSXk9kM8TzxLNIyi5iQhfqNhLZM13U8PVVQq1bx8lzDoD/EarlBo9FGq9WCptXpvoF6vYZms4FWswm920en00OnraPb6cMYGnROt3uhaZoYj8dOnU6nWK2W+9SzGebzuVMti47MYuFUe++wb6e299Z04O31G8p0vkGCjfcaAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='register' title='register' src='/static/b7390035decf56fcfa637b2315e26f27/ca1dc/register.png' srcset='/static/b7390035decf56fcfa637b2315e26f27/e7570/register.png 170w,\n/static/b7390035decf56fcfa637b2315e26f27/f46e7/register.png 340w,\n/static/b7390035decf56fcfa637b2315e26f27/ca1dc/register.png 680w,\n/static/b7390035decf56fcfa637b2315e26f27/78d47/register.png 800w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>Lua VM, Dalvik VM</li>\n<li>피연산자가 CPU의 레지스터에 저장된다.</li>\n<li>Push, Pop 연산자가 없다.</li>\n<li>명령어가 피연산자의 위치인 레지스터의 주소를 기억해야 한다.</li>\n<li>\n<p>장점</p>\n<ol>\n<li>Pop, Push 과정이 없기 때문에 같은 덧셈이라도 하나의 명령으로 충분하다.</li>\n<li>스택기반에서는 할 수 없는 명령어 최적화를 적용할 수 있다. 예) 어떤 연산이 나중에 또 필요할 때, 레지스터에 저장하여 다시 계산하지 않고도 결과를 활용할 수 있다.</li>\n</ol>\n</li>\n<li>\n<p>단점</p>\n<ol>\n<li>스택기반보다 명령어의 길이가 길다. 피연산자의 주소를 명시해줘야 하기 때문에.</li>\n</ol>\n</li>\n</ul>\n<h3>심볼릭 레퍼런스</h3>\n<p>심볼릭 레퍼런스란 참고하는 클래스의 특정 메모리 주소를 참조 관계로 구성한 것이 아니라, 참조하는 대상의 이름만을 지칭한 것이다.</p>\n<h3>JVM 구조</h3>\n<p align='center'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 325px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/66d4232fcddc2016ed265d6c4fc7a8a0/e5cc6/jvm.png.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 107.6470588235294%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAIAAABPIytRAAAACXBIWXMAAA7EAAAOxAGVKw4bAAADNElEQVQ4y31TW5eiOBD2//+ifdnds7Ozduu0yEUBuYSQEEgI95uoqFu0PZ7ueZg6H6EqVV9SSVUW9/u97kebZAGvUFIFvAaAKaseXLcb4Fe5/5QFfEw2eT0QSjGhjutjjJtudGg+k++/k5lM0qpoR9OyX15fly+rP//6u2oH2Bxc0zSVjSyaNK/ToslA74bmnXj7IOfNYIUSxeVSR6qbYF4faMGLDlxNV1reVuYizRORsYC6brh/P85P8tPAcbF3bC78KPbCyMHUNV3FOug4IJqma6ruuR6OnC/k6/U2jBdQvqvo2+Ywnk5l0/ZDP10mIRnPSNe2tm3SiF6mE2aHL+QgqV53oYmSV93/sccOSVd7QtL5bKfzCNFMBEkWxjIEPc3ZF3IoaoTpTt0YmmKoyvrle0iiB/n6LMzz/0ned+Y1Eq1HkrXhaAdsuDiQHZHto86/K1WbZcxDhmp5lvfvUn+B1G0wzQSFRcRyGmUAQn+BDEmdykVo7IaqvnTD/TSuFFvRnPt4vPTDsW6avAAMdTNC0zTdsW6PzYyx7fqyAuJC+EHVFqHwi5avd+qbqRetwInbHdtHblWXU+EzGfKCMomTnNAUQasIFMxkWSYy51Kmfd+WRSaESDPGZbTUgpWBI46GsTcMHSq9Xq9wiNuukkWcIrwQXpCVSRRj+2CzmNoHEyQWIc8izaY7N6LcP12OIhW6tn17W3dd2w31k4zKJiOJVzbJxtIN1yxbjpnT9vUj7brNE0mKiq8M3UIOKGD2Q8N9tIgdFwryqOc3xX8zybO87+/x/mhBGP9YWtA/Hx1yuyWuN5On6XK+nGByY6K9N5Mv0/l6nWbc4IM2hea9/afaKEpAgeDr9TqTXU1B1IIGhIthAkXcD+BJPMBcGEPmwgyci6WPgBk+2ceuu1Bf/4EzwErj6QhLDke4WG273ZjWHrDZ/HA9R1UVhDzwjucRwiARF++obS/wfpcWLK9EVvEZJU/zGMAESYuYxkEiKZRN5AxcHzEVF3k0p82sw3Q6f4a125vGDkZD1dSNoilbUMA8H8fPYZFlL0ouEs8TCH1CAGMaYFBSjEUQpEHwNQDBtmXC/wfwtLk21UTlVwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='jvm png' title='jvm png' src='/static/66d4232fcddc2016ed265d6c4fc7a8a0/e5cc6/jvm.png.png' srcset='/static/66d4232fcddc2016ed265d6c4fc7a8a0/e7570/jvm.png.png 170w,\n/static/66d4232fcddc2016ed265d6c4fc7a8a0/e5cc6/jvm.png.png 325w' sizes='(max-width: 325px) 100vw, 325px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>작성한 코드는 다음과 같은 과정을 통해 수행된다.\n클래스 로더가 컴파일된 자바 바이트코드를 런타임 데이터 영역에 로드하고, 실행 엔진이 자바 바이트 코드를 실행한다.</p>\n<h3>Class Loader</h3>\n<p>자바는 컴파일 타임이 아니라 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다. 이 동적로드를 담당하는 부분이 클래스 로더이다.\n클래스 로더의 특징으로는 다음이 있다.</p>\n<ul>\n<li>계층 구조: 클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성된다. 최상위는 부트스트랩 클래스 로더이다.</li>\n<li>위임 모델: 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 동작한다. 클래스를 로드할 때 상위 클래스 로더를 확인하여 해당 클래스 로더에 있다면 클래스를 사용하고, 없다면 로드를 요청받은 클래스로더가 클래스를 로드한다.</li>\n<li>가시성 제한: 하위 클래스로더는 상위 클래스로더의 클래스를 찾을 수 있지만, 반대 경우는 찾을 수 없다.</li>\n<li>언로드 불가: 클래스로더는 클래스를 로드할 수는 있지만 언로드할 수는 없다. 대신, 현재 클래스 로더를 삭제하고 아예 새로운 클래스로더를 생성하는 방법을 사용할 수 있다.</li>\n</ul>\n<p>각 클래스로더는 클래스들을 보관하는 네임스페이스를 갖는다. 클래스를 로드할 때 이미 로드된 클래스인지 확인하기 위해서 네임스페이스에 보관된 FQCN(Fully Qualified Class Name)을 기준으로 클래스를 찾는다.</p>\n<p align='center'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 310px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/2557c5153441651089c2a72575fda246/56e1b/link.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 51.764705882352935%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABVElEQVQoz21Ry07DMBDs//8OF4TEBYkroLZ523Fsx3k5cZyHE8dNA4YegCqrkbVa72hmdw+f/2NQU0wyvRhM2OnsHk9OI6TsxxAS+7tt29/mA8urqm55I0veVlwMo7L5Zd3UtIzzMio964teLgnNd8gFlxGA7x9HGCOr+fj86gTJOBuU4DCCYQh4LSoxIpLtkGPMgih2/cgPIUCUZmWa19qsTdthVrKcC9kPatknr+t6K91eNc0lF4tZtbnSQnajtXydZr1v+25hto9knIve9UMLL4gQppUY9pXvyFa54ELNpu0ngIui7up2GCeNf5RnvejlG7dkh8yK2g7ZDYrkjbVgdy77CWIGkzSCOCEM4ZTQzAdkxzbNa9krACEA0B6CZUXbz29H7+HpBSLieL5jhwHwHNKD/hPGmFZ2EcryuqdF+4tcAJRWFT+7gT2KFwA/BCc3+AKnBTJ95g3S+QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='link' title='link' src='/static/2557c5153441651089c2a72575fda246/56e1b/link.png' srcset='/static/2557c5153441651089c2a72575fda246/e7570/link.png 170w,\n/static/2557c5153441651089c2a72575fda246/56e1b/link.png 310w' sizes='(max-width: 310px) 100vw, 310px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>클래스 로더가 아직 로드되지 않은 클래스를 찾으면, 다음과 같은 과정을 통해 클래스를 로드하고 링크하고 초기화한다.</p>\n<ul>\n<li>로드: 클래스를 파일에서 가져와서 JVM의 메모리에 로드한다.</li>\n<li>검증: 읽어들인 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사한다.</li>\n<li>준비: 클래스가 필요로 하는 메모리를 할당하고, 클래스에서 정의된 필드, 메서드, 인퍼페이스들을 나타내는 데이터 구조를 준비한다.</li>\n<li>분석: 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.</li>\n<li>초기화: 클래스 변수들을 적절한 값으로 초기화한다. static initializer들을 수행하고, static 필드들을 설정된 값으로 초기화한다.</li>\n</ul>\n<h3>Runtime Data Area</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/1747e4211ce3a5c9b69cb566389ef4a0/b842e/runtime.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 89.41176470588235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACyElEQVQ4y3WU63KbMBCF/f4vlell+iOTtNPE99gGDBhzB93Bdk5XwsRpk3rmWOLT7tFKSExeX19xuVxg2/E3ss+41eFwQBRFSJLEtVZVVbmYiTEGp9MJUko0TQPGGEb2P25ba1AUBcqyBOccWmt0XYeJ/RsSBcIwxJFm7ShhSO4hBHfcVjUm9X3vTGxlaZo6drmcHSdDAyYkglwgyLjTnvp126Jh4sapDQuBlnEUNaNnysnYwHMO5SYzmPTkzqXBNjdYxQzrRGBH/ZZTstDYZAbLuHXcKwwEbUHZSuIdlhHxo4RP3HT9bclGCfBjAJaQqOXpHoIzaMnAE98xOyaz0G2NbGuKv3GRR+ipOmdonXtKlLtfKBb3qJb30P4TJGvQ8QZy8/jGu/0UStILqHOId9yEc5yMpiqdYYdOC5xaH6ay8qi/hxQtVc5wam78zEIyFFC8xvka39l44rZC81ahqaHzH0i9O5ThF5zqezKs0amC+HfHK+Ln9gGKJtE8gcq+4bi7Qx19Jf4Tp17dDDvN0B6fUB+f0aTP4PkMylXYoDn+JhGncVEsoGm/JSsGnk4HXq7I0B6160uRtGRl5F9iZCgUHQejoDsFZXXlnPbc8jF2yFfDOTSdRtxuEdRL0uraLrFvVk6WrZMnbKiakQ38GkfjfjVHJiJ3QZxhwjyEzRpR+/JBMdvAyxd01hauHzUfY+wEhYhHww5xWsKPMwSHHEF8k2WbIMY2OGBnFSbXsewWRzlelCEr28FQa7oJ3hHTbYrZLht07c93OR5nPh6mHrUBfq8izL38bXy2tTEZnl4S7KJiMLR3cL3P6bppWtpVdJW2qcTzLsU8KDDfl5j5udOUZMfHWHvt1gdOqyndx2Si6auyDjIs9xXWYYXVKHpeUPK/WtIEq3dx67DG3LdLL3E+U4X2e1c3DEXVfFBZf67PYpuWrqRS+AMImUtZKOyk+gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='runtime' title='runtime' src='/static/1747e4211ce3a5c9b69cb566389ef4a0/ca1dc/runtime.png' srcset='/static/1747e4211ce3a5c9b69cb566389ef4a0/e7570/runtime.png 170w,\n/static/1747e4211ce3a5c9b69cb566389ef4a0/f46e7/runtime.png 340w,\n/static/1747e4211ce3a5c9b69cb566389ef4a0/ca1dc/runtime.png 680w,\n/static/1747e4211ce3a5c9b69cb566389ef4a0/02d09/runtime.png 1020w,\n/static/1747e4211ce3a5c9b69cb566389ef4a0/b842e/runtime.png 1142w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>런타임 데이터 영역은 JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 런타임 데이터 영역은 6개의 영역으로 나눌 수 있다.</p>\n<ul>\n<li>PC Register: 스레드가 시작될 때 생성되며 스레드마다 하나씩 존재한다. 스레드가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행중인 JVM 명령의 주소를 갖는다.</li>\n<li>JVM Stack: 스레드의 수행 정보를 스택프레임을 통해서 저장한다. 메소드가 호출되면 메소드와 정보는 스택에 쌓이고 종료될 때 스택포인트에서 제거된다. 스택 프레임은 지역 변수 배열, 피연산자 스택, 현재 실행중인 메서드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스를 갖는다.</li>\n<li>Native method Stack: 자바 외의 언어로 작성된 네이티브 코드를 위한 스택이다.</li>\n<li>Method Area: 메소드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 정보, static 변수,메서드의 바이트코드 등을 보관한다.</li>\n<li>Runtime Constant Pool: 클래스 파일 모맷에서 상수 풀 테이블에 해당하는 영역이다. 메스드 영역에 포함되있지만 JVM동작에서 가장 핵심적인 역할을 수행하는 곳이다. 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아 참조한다.</li>\n<li>Heap: 객체를 저장하는 공간으로 가비지 컬렉션의 대상이다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다.</li>\n</ul>\n<h3>Execution Engine</h3>\n<p>런타임 데이터 영역에 배치된 바이트코드는 실행 엔진에 의해 실행된다. 실행 엔진은 명령어 단위로 읽어서 실행한다. 실행 엔진은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경하며, 그 방식은 두가지가 있다.</p>\n<ol>\n<li>인터프리터: 명령어를 하나씩 읽어서 해석하고 실행한다. 바이트코드 하나하나의 해석은 빠른 대신 인터프리팅 결과의 실행은 느리다는 단점을 가지고 있다. 흔히 얘기하는 인터프리터 언어의 단점을 그대로 가지는 것이다.</li>\n<li>JIL(Just-In-Time): 인터프리터의 단점을 보완하기 위해 도입된 것이 JIT 컴파일러이다. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고 실행하는 방식이다.</li>\n</ol>","frontmatter":{"title":"Java Virtaul Machine","date":"January 29, 2022","update":"January 29, 2022","tags":["java"],"series":null},"fields":{"slug":"/jvm/","readingTime":{"minutes":12.41}}},"seriesList":{"edges":[{"node":{"id":"aeeabe20-f428-571f-a085-6cb528323517","fields":{"slug":"/jvm/"},"frontmatter":{"title":"Java Virtaul Machine"}}},{"node":{"id":"d322ca1f-aa27-5fc4-8ceb-7982c5738663","fields":{"slug":"/hashing/"},"frontmatter":{"title":"해싱이란?"}}},{"node":{"id":"85f7d472-c933-5918-9df5-33510bbd5c40","fields":{"slug":"/primitive-type/"},"frontmatter":{"title":"기본 타입(primitive type)"}}},{"node":{"id":"bbbb67ac-6c95-5684-b034-0f5e0ddc8ca1","fields":{"slug":"/equals/"},"frontmatter":{"title":"equals와 =="}}},{"node":{"id":"9c040466-1d6f-5b3f-b1e2-b611a0920f53","fields":{"slug":"/stringPool/"},"frontmatter":{"title":"String Pool"}}},{"node":{"id":"e9ec703f-3d62-523a-b7c7-f121c47bbf9f","fields":{"slug":"/string/"},"frontmatter":{"title":"문자열 중복 "}}},{"node":{"id":"c8e0cf33-615a-59be-bc1e-e26c406c927d","fields":{"slug":"/hashmap/"},"frontmatter":{"title":"HashMap"}}},{"node":{"id":"4e14a9fa-fa01-5cbc-9153-9bc68655ca17","fields":{"slug":"/generic/"},"frontmatter":{"title":"제너릭(Generic)"}}},{"node":{"id":"7c769d15-9003-56b7-9fc5-b1b960da36c0","fields":{"slug":"/process/"},"frontmatter":{"title":"[운영체제(OS)] 1.프로세스"}}},{"node":{"id":"4da2182b-2793-5418-a407-01f29fbbd757","fields":{"slug":"/map/"},"frontmatter":{"title":"HashMap, HashTable, ConcurrentHashMap"}}},{"node":{"id":"15a49153-8fff-5ab6-953e-5215b8e2faec","fields":{"slug":"/process2/"},"frontmatter":{"title":"[운영체제(OS)] 2.프로세스-IPC"}}},{"node":{"id":"0e33327d-d671-5b12-aa17-919f5b7107bd","fields":{"slug":"/thread/"},"frontmatter":{"title":"[운영체제(OS)] 3. 쓰레드(Thread)"}}},{"node":{"id":"794b97e8-63d4-5ed3-b203-d391651ec308","fields":{"slug":"/atomic/"},"frontmatter":{"title":"Java - Atomic"}}},{"node":{"id":"e7ea69fe-b48d-530a-9cb3-6cb7afeb7f67","fields":{"slug":"/adder-accumulator/"},"frontmatter":{"title":"Java - LongAdder와 LongAccumulator"}}},{"node":{"id":"678a2cb4-6b30-5113-9297-704160fe3a46","fields":{"slug":"/lambda/"},"frontmatter":{"title":"Java - 람다와 함수형 인터페이스"}}},{"node":{"id":"ea516931-cf7d-5fe6-a5e2-43145feed0e7","fields":{"slug":"/var/"},"frontmatter":{"title":"Java - var"}}},{"node":{"id":"03eac536-09bf-5d35-9903-1e5eff2c7123","fields":{"slug":"/fetch/"},"frontmatter":{"title":"JPA - 즉시로딩과 지연로딩"}}},{"node":{"id":"97f1315c-697a-52a2-ae72-77e3cb4869ec","fields":{"slug":"/content-type/"},"frontmatter":{"title":"[토이 프로젝트] - Content-Type - application/json"}}}]},"previous":null,"next":{"fields":{"slug":"/hashing/"},"frontmatter":{"title":"해싱이란?"}}},"pageContext":{"id":"aeeabe20-f428-571f-a085-6cb528323517","series":null,"previousPostId":null,"nextPostId":"d322ca1f-aa27-5fc4-8ceb-7982c5738663"}},"staticQueryHashes":[]}