{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"토이 프로젝트 코드에서의 문제점 이번에 Comment 기능에 대해 단위 테스트 코드를 작성하고 보냈던 PR에 멘토님이 이런 코드리뷰를 해주셨다.  Controller에서 테스트 코드를 작성하고 결과를 비교하는데, \"댓글이 삭제되었습니다.\" 응답이  필터가 적용되었는데 계속 ???로 응답이 됐다. 그래서 구글링을 해 억지로 헤더에 을 적용시켜서 해봤더니 작…","fields":{"slug":"/content-type/"},"frontmatter":{"date":"May 09, 2022","title":"[토이 프로젝트] - Content-Type - application/json","tags":["java","spring"]},"rawMarkdownBody":"\n## 토이 프로젝트 코드에서의 문제점\n\n이번에 Comment 기능에 대해 단위 테스트 코드를 작성하고 보냈던 PR에 멘토님이 이런 코드리뷰를 해주셨다.\n\n![](1.png)\n\nController에서 테스트 코드를 작성하고 결과를 비교하는데, \"댓글이 삭제되었습니다.\" 응답이 `UTF-8` 필터가 적용되었는데 계속 ???로 응답이 됐다. 그래서 구글링을 해 억지로 헤더에 `\"Content-Type\", \"application/json; charset=UTF-8\"`을 적용시켜서 해봤더니 작동이 잘되서 바로 PR을 날렸는데 저런 리뷰를 해주셨다.\n\n지금까지 했던 프로젝트는 아무생각없이 json을 사용했었고 이번에도 별 생각없이 구글링 한 결과를 복붙했는데 리뷰를 보고 그러게 왜 문자열인데 application/json을 적용했지라는 생각이 들면서 json이 정확하게 뭐지라는 생각이 들어서 포스팅을 하게됐다.\n\n## JSON\n\n[Json 공식 페이지](https://www.json.org/json-ko.html)에서는 JSON을 다음과 같이 설명하고 있다.\n\n> **JSON** (JavaScript Object Notation)은 경량의 DATA-교환 형식이다. 이 형식은 사람이 읽고 쓰기에 용이하며, 기계가 분석하고 생성함에도 용이하다.\n>\n> JSON은 두개의 구조를 기본으로 두고 있다.\n>\n> - name/value 쌍의 collection 타입으로, 다양한 언어들에서, 이는 _object_, record, struct(구조체), dictionary, hash table, 키가 있는 list, 또는 연상배열로서 실현 되었다.\n> - 값들의 순서화된 리스트로, 대부분의 언어들에서, 이는 _array_, vector, list, 또는 sequence로서 실현 되었다.\n\n위의 설명대로 JSON은 name/value 의 컬렉션인데, 당연히 내가 작성한 \"댓글이 삭제되었습니다.\" 라는 응답의 문자열을 application/json이라는 Content-Type으로 헤더를 작성한게 말이 안되는 설정이었다.\n\n굳이 Content-Type을 설정하려면 말씀해주신대로 text/plain이 맞는 설정이라 생각하고, 프론트 개발을 접했을 때를 생각하니 React에서 Response를 `const {status, data} = response 이런식으로 사용할텐데 단순히 문자열 value 값만 온다면 처리가 힘들어 진다는 부분도 이해가 됐다.\n\n## 해결방안\n\n생각한 해결방안은 그냥 void로 리턴을 하던가, 간단한 응답 객체를 만들어 리턴하는 방식인데, 나는 그래도 처리에 대한 간단한 메세지 정도는 있는게 좋을 것 같아 간단한 응답 객체를 만들기로 했다.\n\nSimpleMessageResponse.java\n\n```java\n@AllArgsConstructor\n@Getter\npublic class SimpleMessageResponse {\n    private int status;\n    private String message;\n}\n```\n\nCommentController.java\n\n```java\n@DeleteMapping(\"/posts/{postId}/comments/{commentId}\")\npublic ResponseEntity<SimpleMessageResponse> commentRemove(@PathVariable Long commentId) {\n    commentService.removeComment(commentId);\n    return new ResponseEntity<>(new SimpleMessageResponse(HttpStatus.OK.value(), commentId + \": 댓글이 삭제되었습니다.\"),HttpStatus.OK);\n}\n```\n\nSimpleMessageResponse 응답 클래스를 만들어 주었고 Controller는 다음과 같이 수정했다.\n\nCommentControllerTest.java\n\n```java\n@Test\n@DisplayName(\"id에 해당하는 comment가 있으면 정상적으로 comment를 삭제한다\")\nvoid commentRemove() throws Exception{\n  final Long ID = 1L;\n  mockMvc.perform(delete(\"/posts/1/comments/{commentId}\", ID))\n    .andExpect(status().isOk())\n    .andExpect(jsonPath(\"$.status\").value(200))\n    .andExpect(jsonPath(\"$.message\").value(ID+\": 댓글이 삭제되었습니다.\"))\n    verify(commentService,times(1)).removeComment(ID);\n}\n```\n\n![스크린샷 2022-05-09 오후 10.09.52](2.png)\n\n테스트 코드를 수정하고 테스트를 실행해보니 잘 돌아간다.\n\n## Post 요청과 Content-Type의 관계\n\n글을 작성하려고 서칭을 하다보니 [Post 요청과 Content-Type의 관계에](https://blog.naver.com/PostView.naver?blogId=writer0713&logNo=221853596497&redirect=Dlog&widgetTypeCall=true&directAccess=false) 대한 포스팅을 읽게 되었다.\n\n보통 RestAPI의 경우 Json 타입으로 요청하고, 요청을 받는데 그래서 당연히 Content-Type application/json 으로 사용한다고 생각하지만 html form 태그에서 post 방식으로 요청하거나, jQuery의 ajax요청 같은 상황에서는 \"application/x-www-form-urlencoded; charset=UTF-8\"이 사용된다.\n\njQuery 공식문서에는 다음과 같이 써있다.\n\n> Default is \"application/x-www-form-urlencoded; charset=UTF-8\", which is fine for most cases. If you explicitly pass in a content-type to `$.ajax()`, then it is always sent to the server (even if no data is sent). As of jQuery 1.6 you can pass `false` to tell jQuery to not set any content type header.\n\n그래서 Content-Type에 따라서 client에서 server로 보내는 데이터의 형식이 달라진다.\n\n- application/x-www-urlencoded\n\n  ```\n  POST / HTTP/1.1\n  Host: localhost\n  Content-Type: applicaton/x-www-form-urlencoded\n\n  name=lim&age=20\n  ```\n\n- application/json\n\n  ```\n  POST / HTTP/1.1\n  Host: localhost\n  Content-Type: applicaton/json\n\n  {\n  \t\"name\":\"lim\",\n  \t\"age\":\"20\"\n  }\n  ```\n\n### 백엔드에서 처리\n\n그럼 프론트에서 보내는 요청의 데이터 형식에 따라서 벡엔드는 어떻게 처리해야될까?\n\n`@RequestBody, @ModelAttribute, @RequestParam` 등의 어노테이션을 사용하면 해당 어노테이션과 매칭되는 메세지 컨버터가 `ResquestMappingHandlerAdapter`의 동작을 통해서 등록된다. `AnnotationMethodHandlerAdapter`는 Spring 3.2 부터 deprecating 되었다.\n\n기존에 Json으로 요청을 보내는 방식에 추가적으로 x-www-urlencoded 방식을 추가로 제공하려면 다음과 같이 사용하면된다.\n\n```java\n@PostMapping(value = \"/users\", consumes = MediaType.APPLICATION_JSON_VALUE)\n    public ResponseEntity<UserResponseDTO> userSave(@RequestBody @Valid CreateUserRequest createUserRequest){\n        log.info(\"json request. username: {}\",createUserRequest.getUsername());\n        User user = userService.addUser(createUserRequest.toCommand());\n        return new ResponseEntity<>(UserResponseDTO.from(user), HttpStatus.CREATED);\n    }\n\n    @PostMapping(value = \"/users\", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n    public ResponseEntity<UserResponseDTO> userSaveFormRequest(@Valid CreateUserRequest createUserRequest){\n        log.info(\"form request. username: {}\",createUserRequest.getUsername());\n        User user = userService.addUser(createUserRequest.toCommand());\n        return new ResponseEntity<>(UserResponseDTO.from(user), HttpStatus.CREATED);\n    }\n```\n\n첫 번째 메소드는 json, 두번째 메소드는 x-www-urlencoded 타입을 받게 된다.\n\n테스트 코드\n\n```java\n    @Test\n    @DisplayName(\"application/json 타입의 회원가입 요청을 정상적으로 처리하고 가입 유저를 반환한다. \")\n    void userSaveJsonRequest() throws Exception {\n        final String USERNAME = \"user1\";\n        final String PASSWORD = \"1234\";\n        CreateUserRequest createUserRequest = new CreateUserRequest(USERNAME, PASSWORD);\n        User user1 = new User(1L, USERNAME, PASSWORD);\n        UserResponseDTO userResponse = UserResponseDTO.from(user1);\n        when(userService.addUser(any(CreateUserCommand.class))).thenReturn(user1);\n\n        ResultActions resultActions = mockMvc.perform(\n                post(\"/users\")\n                        .contentType(MediaType.APPLICATION_JSON)\n                        .content(objectMapper.writeValueAsString(createUserRequest))\n        );\n\n        resultActions.andExpect(status().isCreated())\n                .andExpect(jsonPath(\"id\",userResponse.getId()).exists())\n                .andExpect(jsonPath(\"username\", userResponse.getUsername()).exists());\n\n        verify(userService, times(1)).addUser(any(CreateUserCommand.class));\n    }\n```\n\n![스크린샷 2022-05-10 오후 3.18.48](3.png)\n\n```java\n    @Test\n    @DisplayName(\"application/x-www-form-urlencoded 타입의 회원가입 요청을 정상적으로 처리하고 가입 유저를 반환한다. \")\n    void userSaveFormRequest() throws Exception {\n        final String USERNAME = \"user1\";\n        final String PASSWORD = \"1234\";\n        CreateUserRequest createUserRequest = new CreateUserRequest(USERNAME, PASSWORD);\n\n        User user1 = new User(1L, USERNAME, PASSWORD);\n        when(userService.addUser(any(CreateUserCommand.class))).thenReturn(user1);\n\n        ResultActions resultActions = mockMvc.perform(\n                post(\"/users\")\n                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n                        .param(\"username\",USERNAME)\n                        .param(\"password\",PASSWORD)\n        );\n\n        resultActions\n                .andDo(print())\n                .andExpect(status().isCreated())\n                .andExpect(jsonPath(\"$.id\").value(user1.getId()))\n                .andExpect(jsonPath(\"$.username\").value(user1.getUsername()));\n\n        verify(userService, times(1)).addUser(any(CreateUserCommand.class));\n    }\n```\n\n![스크린샷 2022-05-10 오후 3.19.33](4.png)\n\n테스트도 문제없이 통과한 모습을 볼 수 있다.\n\n코드를 추가하다가 예상치도 못한 곳에서 문제가 발생했었는데 요청받는 객체인 `CreateUserRequest`에서 문제가 생겼었다. @ModelAttribute에서 값을 객체로 바인딩 할때는 기본적으로 프로퍼티 접근법을 사용한다.\n\n- 해당 객체를 생성(기본 생성자)\n- setter를 이용해 값을 객체에 주입\n\n```java\n@Getter\n@NoArgsConstructor\n@AllArgsConstructor\npublic class CreateUserRequest {\n    @NotEmpty\n    private String username;\n\n    @NotEmpty\n    private String password;\n\n    public CreateUserCommand toCommand(){\n        return new CreateUserCommand(username, password);\n    }\n}\n```\n\n기존 코드는 @RequestBody 때문에 @Getter와 @NoArgsConstructor 어노테이션을 추가했었고 테스트 코드에서는 @AllArgsConstructor로 객체를 생성해서 사용했었다.\n\n@ModelAttribute에서도 모든 필드를 매개변수로 받는 생성자로 바인딩을 할 수 있지만, 이미 기본 생성자가 있기때문에 프로퍼티 접근법으로 작동이 되었고 setter가 없어서 계속 에러가 발생한 것이었다.\n\n```java\n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\npublic class CreateUserRequest {\n    @NotEmpty\n    private String username;\n\n    @NotEmpty\n    private String password;\n\n    public CreateUserCommand toCommand(){\n        return new CreateUserCommand(username, password);\n    }\n}\n```\n\n@Setter를 추가하니 문제없이 작동했다.\n"},{"excerpt":"","fields":{"slug":"/adapter/"},"frontmatter":{"date":"March 28, 2022","title":"디자인 패턴 - 어댑터 패턴","tags":["design pattern"]},"rawMarkdownBody":""},{"excerpt":"","fields":{"slug":"/fetch/"},"frontmatter":{"date":"March 25, 2022","title":"JPA - 즉시로딩과 지연로딩","tags":["java","jpa"]},"rawMarkdownBody":""},{"excerpt":"var","fields":{"slug":"/var/"},"frontmatter":{"date":"March 18, 2022","title":"Java - var","tags":["java"]},"rawMarkdownBody":"\n## var\n\n"},{"excerpt":"람다와 함수형 인터페이스 Java에 람다 표현식이 추가됨으로써 함수형 인터페이스, 메서드 참소가 등장할 수 있었습니다. 이를 바탕으로 stream API가 탄생했고, 컬렉션 기반의 기술을 편리하고 빠르게 처리할 수 있게 되었습니다. 이번 포스팅에서는 람다와 함수형 인터페이스에 대해 알아보겠습니다. 람다 표현식이 필요한 이유 자바 기반의 프로그램은 계속해서…","fields":{"slug":"/lambda/"},"frontmatter":{"date":"March 11, 2022","title":"Java - 람다와 함수형 인터페이스","tags":["java"]},"rawMarkdownBody":"\n## 람다와 함수형 인터페이스\n\nJava에 람다 표현식이 추가됨으로써 함수형 인터페이스, 메서드 참소가 등장할 수 있었습니다. 이를 바탕으로 stream API가 탄생했고, 컬렉션 기반의 기술을 편리하고 빠르게 처리할 수 있게 되었습니다. 이번 포스팅에서는 람다와 함수형 인터페이스에 대해 알아보겠습니다.\n\n## 람다 표현식이 필요한 이유\n\n자바 기반의 프로그램은 계속해서 비대해지고 있습니다. 유연성과 다양성을 확보하기 위해 인터페이스 기반으로 개발을 많이하는데, 이 때문에 별도로 구현된 클래스를 만들기도하고 간단한 코드의 경우 중첩 클래스나 익명 클래스 형태로 내용을 구현하게 됩니다. 하지만 익명 클래스를 많이 만들면 비즈니스 로직의 구현보다 그것을 담기 위한 코드를 많이 작성하게 되고 중복되는 코드가 많아지는 문제가 생깁니다.\n\n이러한 반복적이고 비효율적인 구조를 개선하고자 익명 클래스를 단순화하여 그 표현식을 메서드의 인수로 전달하거나 인터페이스의 객체를 생성할 수 있는 기능을 제공하는 람다 표현식이 생기게되었습니다.\n\n먼저 간단한 예제를 통해 람다 표현식의 모습을 알아보겠습니다.\n\n```java\npublic class BaseballPlayer {\n    private String teamName;\n    private String playerName;\n\n    ...\n\n    public static void main(String[] args){\n        List<BaseballPlayer> list = new ArrayList();\n\n        list.sort(new Comparator<BaseballPlayer>(){\n            @Override\n            public int compare(BaseballPlayer object1, BaseballPlayer object2){\n                return object1.getPlayerName().compareTo(object2.getPlayerName());\n            }\n        });\n    }\n}\n```\n\n객체의 비교를 비교하기 위해서는 Comparable를 구현해 compareTo 메서드를 재정의 하거나 Comparator 인터페이스같이 외부에서 비교 기능을 정의해서 주입할 수 있습니다. 위의 예제는 익명클래스를 이용해 list의 sort 메서드를 정의했습니다.\n\n이제 위의 코드를 람다 표현식으로 변경해 보겠습니다.\n\n```java\nlist.sort((BaseballPlayer object1, BaseballPlayer object2)->{\n    object1.getPlayerName().compareTo(object2.getPlayerName())\n})\n```\n\n두 코드를 비교해 보면 익명 클래스의 상당히 많은 부분이 추약되고 생략된 것을 확인할 수 있습니다.\n\n그러면 람다 표현식을 사용함으로 얻는 장점을 무엇일까?\n\n- 이름 없는 함수를 선언할 수 있습니다. 메서드는 반드시 특정 클래스나 인터페이스 안에 포함되어야 하고 이름이 있어야 하지만, 람다 표현식은 이러한 제약에서 벗어날 수 있습니다.\n- 소스 코드의 분량을 획기적으로 줄일 수 있어, 반복저으로 작업해야 하는 기존의 비효율적인 코드 작성 방식이 필요 없습니다.\n- 코드를 파라미터로 전달할 수 있습니다. 외부에서 동작을 정의해서 메서드에 전달할 때 편리하게 사용할 수 있습니다.\n\n## 람다 표현식 이해하기\n\n메서드를 구성하는 요소에 대해 생각해보면 다음과 같습니다.\n\n1. 메서드의 이름\n2. 메서드에 전달되는 파라미터 목록\n3. 메서드를 구현한 본문\n4. 메서드의 리턴 타입\n\n람다 표현식은 이 구성요소 중 1,4번은 생략하고 2,3번만을 작성하며 코드를 단순화 시킵니다.\n\nRunnable 인터페이스를 익명클래스로 쓰레드 객체를 생성하는 코드를 예를 들어 람다 표현식 전환 과정을 보겠습니다.\n\n```java\nThread thread = new Thread(new Runnable(){\n    @Override\n    public void run(){\n        System.out.println(\"hello\");\n    }\n});\n```\n\n### 1. 익명 클래스 선언부 제거\n\n```java\nThread thread = new Thread(\n    @Override\n    public void run(){\n        System.out.println(\"hello\");\n    }\n);\n```\n\nThread 생성자의 인수는 Runnable 인터페이스가 혹은 이를 구현한 클래스로 한정되기 때문에 인터페이스명을 다시 선언할 필요가 없습니다.\n\n### 2. 메서드 선언부 제거\n\n```java\nThread thread = new Thread(\n    {\n        System.out.println(\"hello\");\n    }\n);\n```\n\n메서드명과 리턴 타입을 제거합니다. 리턴 타입이 생략되더라도 자바 컴파일러가 데이터 타입 추론을 통해 자동으로 결정해 줍니다.\n\n### 3. 람다 문법으로 정리\n\n```java\nThread thread = new Thread(() -> System.out.println(\"hello\");\n);\n```\n\n파라미터 목록을 메서드의 본문으로 전달한다는 의미로 '->' 기호를 사용합니다. 위의 경우 입력 파라미터가 없지만 () 같이 명시를 해줘야 됩니다.\n\n람다 표현식 문법을 설명하면서 메서드 파라미터에 익명 클래스를 선언하듯이 람다 표현식을 직접 전달하는 형태로 예제를 알아봤습니다.\\\n하지만 이 방식은 코드가 조금 길어지거나 람다 표현식 자체를 재사용할 필요가 있을 때 활용성이 떨어지는 단점이 있습니다. 그래서 표현식 자체를 변수로 선언할 수 있습니다.\n\n```java\nRunnable runImpl = () -> System.out.println(\"hello\");\nThread thread = new Thread(runImpl);\n```\n\n코드를 분리해 위와 같이 변경할 수 있습니다.\n\n더 나아가 메서드의 리턴 타입으로 함수형 인터페이스와 람다 표현식을 조합해서 사용할 수 있습니다.\n\n```java\npublic Runnable getRunnable(){\n    return () -> System.out.println(\"hello\");\n}\n\nRunnable runImpl = getRunnable();\n```\n\n`getRunnable`의 `return` 뒤 표현식은 Runnable 인터페이스를 정의하는 부분으로, `println`이 실행되는 것은 아닙니다.\n`runImpl`에서 `run`메서드가 호출되어야 람다가 실행됩니다.\n\n### 형식 추론\n\n인터페이스에 정의되어 있는 메서드의 파라미터 타입은 사전에 정의하거나 제네릭을 이용해서 타입을 선언합니다. 즉, 어떤 데이터 타입을 사용할지 알고 있기 때문에 이 부분도 생략 가능합니다.\n\n```java\n(String str) -> System.out.println(str);\n(str) -> System.out.println(str);\n```\n\n위의 코드는 동일한 람다 표현식 입니다.\n하지만 코드상에서 타입까지 생략하면 가독성이 떨어지고, 어떤 타입이 올지 인터페이스의 메서드 명세서를 참조해야만 알 수 있기 때문에 타입을 명시 할지 말지는 고려하는게 좋습니다.\n\n### 람다 표현식과 변수\n\n표현식 외부 변수도 참조가 가능합니다. 외부 변수를 참조하기 위해서는 반드시 `final` 이거나 `final`과 유사한 조건이어야 합니다. `final` 키워드가 붙지 않아도 값이 할당된 이후에 변경될 가능성이 없다면 컴파일러는 `final` 변수와 동일하게 취급하며, 컴파일 오류가 발생하지 않습니다\n\n```java\nint num = 100;\nlist.strean().forEach((String s) -> System.out.println(s +\"+\"+ num));\n```\n\n## 함수형 인터페이스의 기본\n\n기본적으로 람다 표현식을 사용할 수 있는 인터페이스는 오직 `public` 메서드 하나만 가지고 있는 인터페이스여야 합니다. 이러한 인터페이이스는 함수형 인터페이스라 부르고, 내부의 추상 메서드를 함수형 메서드라 부릅니다. `Runnable` 인터페이스의 경우 `run` 메서드 하나뿐이기 때문에 컴파일러에 의해 람다 표현식이 해당 메서드의 파라미터와 형식에 맞는지 검사하고 컴파일 됩니다.\n\n자바 버전 업그레이드에 따라 인터페이스에 `default`,`static`,`private` 메서드가 추가되었습니다. 이러한 메서드들이 추가되어 있어도 오직 하나의 추상 메서드만이 존재하면 함수형 인터페이스고 해당 메서드를 함수형 메서드로 인식합니다.\n\n사용자 입장에서는 함수형 인터페이스의 조건이 불편하지 않겠지만 프레임워크나 API를 개발하는 개발자 입장에서는 매번 람다 표현식을 위해 인터페이스를 제공하는 것이 번거로울 수 있습니다. 그래서 자바 8에서는 많이 사용할 만한 패번을 정리해 함수형 인터페이스로 만들고 `java.util.function` 패키지로 제공하고 있습니다. 해당 패키지의 자세한 내용은 다음 포스팅에서 알아보겠습니다.\n\n### @FunctionalInterface 어노테이션\n\n함수형 인터페이스는 오직 하나의 추상 메서드를 갖는다는 전제 조건을 만족하면 별도의 어노테이션을 붙이지 않아도 함수형 인터페이스로 취급할 수 있습니다. 하지만 `@FunctionalInterface` 어노테이션을 사용하면 더 명확하게 표현할 수 있고 실수로 추상 메서드를 추가하더라도 컴파일 에러를 일으켜 사전에 문제를 예방할 수 있습니다.\n\n```java\n@FunctionalInterface\npublic interface Consumer<T> {\n}\n\n@FunctionalInterface\npublic interface Comparator<T> {\n}\n```\n\n`Consumer`,`Comparator` 인터페이스에 해당 어노테이션이 적용되어 있는 모습.\n\n## 메서드 참조\n"},{"excerpt":"아이템2 - 생성자에 매개변수가 많다면 빌더를 고려하라 static 팩토리 메소드와 public 생성자는 똑같은 제약이 있습니다. 바로 매개변수가 많아질 때 적절히 대응하기가 어렵다는 점입니다. 각각의 경우를 식품 포장의 영양정보를 표현하는 클래스인  클래스를 예를 들어 설명하겠습니다. 생성자 영양정보 클래스는 1회 내용량, 총 n회 제공량, 1회 제공량…","fields":{"slug":"/item2/"},"frontmatter":{"date":"March 09, 2022","title":"이펙티브 자바 - 아이템 2","tags":["java","effective java"]},"rawMarkdownBody":"\n## 아이템2 - 생성자에 매개변수가 많다면 빌더를 고려하라\n\nstatic 팩토리 메소드와 public 생성자는 똑같은 제약이 있습니다. 바로 매개변수가 많아질 때 적절히 대응하기가 어렵다는 점입니다. 각각의 경우를 식품 포장의 영양정보를 표현하는 클래스인 `NutritionFacts` 클래스를 예를 들어 설명하겠습니다.\n\n### 생성자\n\n영양정보 클래스는 1회 내용량, 총 n회 제공량, 1회 제공량당 칼로리 같은 필수 항목과 총 지방, 트랜스지방, 포화지방, 콜레스테롤 나트륨 등 여러가지의 선택 항목으로 이루어져 있습니다. 몇몇 항목을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class NutritionFacts {\n    private int servingSize;\n    private int servings;\n    private int calories;\n    private int sodium;\n    private int carbohydrate;\n    private int fat;\n\n    public NutritionFacts(int servingSize, int servings) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n    }\n\n    public NutritionFacts(int servingSize, int servings, int calories) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n    }\n\n    public NutritionFacts(int servingSize, int servings, int calories, int fat) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n        this.fat = fat;\n    }\n\n    public NutritionFacts(int servingSize, int servings, int calories, int sodium, int fat) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n        this.sodium = sodium;\n        this.fat = fat;\n    }\n\n    public NutritionFacts(int servingSize, int servings, int calories, int sodium, int carbohydrate, int fat) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n        this.sodium = sodium;\n        this.carbohydrate = carbohydrate;\n        this.fat = fat;\n    }\n}\n```\n\n코드를 보면 점층적 생성자 패턴으로 필수 매개변수만 받는 생성자, 필수 매개변수와 선택 매개변수 n개를 받는 생성자를 가지고 있는 모습을 볼 수 있습니다. 그래서 이 클래스의 인스턴스를 만들려면 원하는 생성자를 골라서 생성하면 됩니다.\n\n```java\nNutritioinFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);\n```\n\n위와 같이 인스턴스를 생성할 수 있지만 사용자는 설정하길 원치 않는 매개변수까지 포함하기 쉬워집니다. 위의 코드는 fat에 0을 넘겼습니다. 지금은 매개변수가 6개 뿐이지만 수가 늘어날수록 이러한 코드는 작성하기도 어려워지고 각 값의 의미가 무엇인지도 헷갈려 읽기도 힘들어집니다.\n\n사용자가 실수로 매개변수의 순서를 바꿔 넘겨줘도 컴파일러는 알아채지 못하고, 런타임에 엉뚱한 동작을 하게 될 것 입니다.\n\n### 자바빈즈 패턴(JavaBeans pattern)\n\n자바빈즈 패턴이란 매개변수가 없는 생상자로 객체를 만든 후, setter 메서드를 호출해 원하는 매개변수의 값을 설정하는 방식입니다.\n\n```java\npublic class NutritionFacts {\n    private int servingSize = -1;\n    private int servings = -1;\n    private int calories = 0;\n    private int sodium = 0;\n    private int carbohydrate = 0;\n    private int fat = 0;\n\n    public void setServingSize(int servingSize) {\n        this.servingSize = servingSize;\n    }\n\n    public void setServings(int servings) {\n        this.servings = servings;\n    }\n\n    public void setCalories(int calories) {\n        this.calories = calories;\n    }\n\n    public void setSodium(int sodium) {\n        this.sodium = sodium;\n    }\n\n    public void setCarbohydrate(int carbohydrate) {\n        this.carbohydrate = carbohydrate;\n    }\n\n    public void setFat(int fat) {\n        this.fat = fat;\n    }\n\n    public static void main(String[] args) {\n        NutritionFacts nutritionFacts = new NutritionFacts();\n        nutritionFacts.setCalories(100);\n        nutritionFacts.setCarbohydrate(27);\n        nutritionFacts.setServings(8);\n        nutritionFacts.setServingSize(240);\n        nutritionFacts.setSodium(35);\n    }\n}\n```\n\n위의 점층적 생성자 패턴의 작성이 어렵고 읽기가 어렵다는 단점은 더 이상 보이지 않습니다. 코드는 길어졌지만 객체를 생성하기 더 쉽고, 읽기 쉬운 코드가 됐습니다.\n\n하지만 자바빈즈 패턴은 객체하나를 만들려면 여러 개의 메서드를 호출해야 하고, 객체가 완전히 생성되기 전까지 일관성이 무너진 상태에 놓이게 됩니다. 중간에 사용되는 경우 안정적이지 않은 상태로 사용될 여지가 있습니다. 또한 setter, getter가 있어서 불편 클래스로 만들 수 없고, 쓰레드 안정성을 보장하려면 lock같은 추가적인 수고가 필요합니다.\n\n이러한 단점 때문에 객체를 freezing하는 방식을 사용할 수 있지만 실전에서는 거의 쓰이지 않습니다. 사용자가 freeze 메서드를 확실히 호출해줬는지 컴파일러가 보증할 방법이 없기 때문입니다.\n\n### 빌더 패턴(Builder pattern)\n\n빌더 패턴이란 사용자가 필요한 객체를 직접 만드는 대신, 필수 매개변수만으로 생성자(혹은 static 팩토리 메서드)를 호출해 빌더 객체를 얻고, 빌더 객체가 제공하는 세터 메서드들로 원하는 선택 매개변수들을 설정하고 마지막으로 `build` 메서드를 호출해 객체를 얻는 방법입니다. 빌더는 생성할 클래스 안에 static 멤버 클래스로 만들어두는게 보통입니다.\n\n코드를 살펴보겠습니다.\n\n```java\npublic class NutritionFacts {\n    private int servingSize;\n    private int servings;\n    private int calories;\n    private int sodium;\n    private int carbohydrate;\n    private int fat;\n\n    public static class Builder{\n        // 필수 멤버\n        private final int servingSize;\n        private final int servings;\n        // 선택 멤버\n        private int calories = 0;\n        private int fat = 0;\n        private int sodium = 0;\n        private int carbohydrate = 0;\n\n        public Builder(int servingSize, int servings) {\n            this.servingSize = servingSize;\n            this.servings = servings;\n        }\n\n        public Builder calories(int val) {\n            calories = val; return this;\n        }\n        public Builder fat(int val) {\n            fat = val; return this;\n        }\n        public Builder sodium(int val) {\n            sodium = val; return this;\n        }\n        public Builder carbohydrate(int val) {\n            carbohydrate = val; return this;\n        }\n        public NutritionFacts build(){\n            return new NutritionFacts(this);\n        }\n    }\n\n    private NutritionFacts(Builder builder){\n        servingSize = builder.servingSize;\n        servings = builder.servings;\n        calories = builder.calories;\n        sodium = builder.sodium;\n        carbohydrate = builder.carbohydrate;\n        fat = builder.fat;\n    }\n}\n```\n\n`NutritionFacts` 클래스는 불변이며, 모든 멤버변수의 기본값들을 한 곳에 모아뒀습니다. 클래스의 정적 내부 클래스 `Builder`의 setter 메서드들은 빌더 자기 자신을 반환하기 때문에 연쇄적으로 메서드를 호출할 수 있습니다. 이러한 방식을 fluent API 또는 method chaining이라고 합니다.\n\n```java\npublic static void main(String[] args) {\n       NutritionFacts nutritionFacts = new NutritionFacts.Builder(240, 8)\n               .calories(100)\n               .sodium(35)\n               .carbohydrate(27).build();\n    }\n```\n\n실제로 객체를 생성하는 코드를 보면 쓰기 쉽고, 일기도 쉬운 것을 볼 수 있습니다. 빌더 패턴은 파이썬이나 스칼라에 있는 named optional parameters를 흉내낸 것입니다. [링크](https://realpython.com/python-optional-arguments/)\n\n유효성 검사 코드는 생략됐습니다. 빌더의 생상자와 메서드에서 입력 매개변수를 검사하고, build 메서드가 호출하는 생성자에서 여러 매개변수에 걸친 불변식(invariant)를 검사하는 방식으로 유효성 검사를 진행할 수 있습니다.\n\n빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에도 좋습니다. 각 계층의 클래스에 관련 빌더를 멤버로 정의하고, 추상 클래스는 추상 빌더를, 구현 클래스에서 구현 빌더를 갖게해 사용할 수 있습니다. 피자를 예를 들어 설명하겠습니다.\n\n```java\npublic abstract class Pizza {\n    public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}\n    final Set<Topping> toppings;\n\n    Pizza(Builder<?> builder){\n        toppings = builder.toppings.clone();\n    }\n\n    abstract static class Builder<T extends Builder<T>>{ //재귀적 타입 매개변수\n    // 비어있는 enumSet 생성\n        EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);\n        public T addTopping(Topping topping) {\n            // Null check\n            toppings.add(Objects.requireNonNull(topping));\n            return self();\n        }\n\n        abstract Pizza build();\n\n        // 하위 클래스는 self 메서드를 재정의하여 this를 반환하도록 해야한다.\n        protected abstract T self();\n    }\n}\n```\n\n`Pizza.Builder` 클래스는 재귀적 타입 매개변수를 사용하는 제네릭 타입입니다. 여기에 추상메서드 `self`를 더해 하위 클래스테서는 형변한을 하지 않고도 메서드 체이닝을 지원할 수 있습니다. self 타입이 없는 자바를 위한 이 방법을 simulated self-type이라고 합니다.\n\nPizza의 하위 클래스 NyPizza의 코드를 살펴보겠습니다.\n\n```java\npublic class NyPizza extends Pizza{\n    public enum Size{SMALL,MEDIUM,LARGE}\n    private final Size size;\n\n    private NyPizza(Builder builder){\n        super(builder);\n        size = builder.size;\n    }\n\n    public static class Builder extends Pizza.Builder<Builder>{\n        private final Size size;\n\n        public Builder(Size size){\n            this.size = Objects.requireNonNull(size);\n        }\n\n        @Override\n        public NyPizza build() {\n            return new NyPizza(this);\n        }\n\n        @Override\n        protected Builder self() {\n            return this;\n        }\n    }\n}\n```\n\n하위 클래스의 빌더가 정의한 `build` 메서드는 해당하는 구현 클래스를 반환하도록 선언했습니다. `NyPizza.Builder`는 `NyPizza`를 반환하고, 이치럼 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 거슬 공변 반환 타이핑(covariant return type)이라고 합니다. 이 기능을 사용하면 위에서 말한대로 형변환없이 빌더를 사용할 수 있습니다.\n\n사용코드\n\n```java\nNyPizza pizza = new NyPizza.Builder(NyPizza.Size.SMALL)\n                        .addTopping(Pizza.Topping.HAM)\n                        .addTopping(Pizza.Topping.MUSHROOM).build();\n```\n\n이처럼 빌더 패턴은 빌더 하나로 여러 객체를 순회하면서 만들 수 있고, 넘기는 매개변수에 따라 다른 객체를 만들 수 있어 매우 유연하다고 할 수 있습니다.\n\n하지만 빌더 패턴은 위의 코드에서 보이듯이 어느정도의 빌더 생성 비용이 있고 점층적 생성자 패턴보다는 코드가 장황하기 때문에 매개변수가 4개 이상은 되어야 값어치를 합니다.\n"},{"excerpt":"동시성","fields":{"slug":"/concurrency/"},"frontmatter":{"date":"March 08, 2022","title":"Effective Java - 동시성(Item 78)","tags":["java","effective java"]},"rawMarkdownBody":"\n## 동시성\n"},{"excerpt":"LongAdder와 LongAccumulator 이전 포스팅에서는 Atomic Type에 대하여 알아보았다. -> Atomic Type에 대하여 Atomic 클래스는 원자성을 보장하고 CAS 알고리즘으로 구현되어있다. 쓰레드 간의 경쟁(Race condition)이 심한 경우 CPU 소모가 크겠지만 Lock을 사용하는 것 보단 성능적 측면에서 우위에 있을…","fields":{"slug":"/adder-accumulator/"},"frontmatter":{"date":"March 04, 2022","title":"Java - LongAdder와 LongAccumulator","tags":["java"]},"rawMarkdownBody":"\n## LongAdder와 LongAccumulator\n\n이전 포스팅에서는 Atomic Type에 대하여 알아보았다. -> [Atomic Type에 대하여](https://hojoon7807.github.io/atomic/)\n\nAtomic 클래스는 원자성을 보장하고 CAS 알고리즘으로 구현되어있다. 쓰레드 간의 경쟁(Race condition)이 심한 경우 CPU 소모가 크겠지만 Lock을 사용하는 것 보단 성능적 측면에서 우위에 있을 것이다.\n\nLongAdder와 LongAccumulator은 AtomicLong에서 사용하는 CAS 연산에 의한 경합 과정에서 CPU 소모를 줄이기 위해 고안되었다.\n\n![](adder.png)\n\nAtomicLong일 경우 위의 그림에서 볼 수 있듯이, 단일 volatile 변수를 공유하기 때문에, CAS를 사용한 반복적인 메모리 읽기 작업과 비교 연산 수행 과정에서 CPU를 많이 소모하게 되고 경합과정이 일어나게 된다.\n\n하지만 LongAdder와 LongAccumulator는 이 문제점을 해결하기 위해 공용 메모리인 **base**와 쓰레드 별 메모리인 **cell**로 나누어 설계되어있다. base 변수를 CAS 방식으로 읽다가 업데이트가 실패하면 while문을 도는 것 대신 쓰레드 별로 cell 메모리에 별도의 연산을 수행한다.\n\n이러한 개념을 **Dynamic Striping**이라고 하며 이를 구현한 Striped64 클래스를 LongAdder와 LongAccumulator가 상속받는다.\n\n## CPU Cache의 False sharing 최소화\n\nongAdder와 LongAccumulator는 cell이라고 하는 여러 개의 개별 변수를 갖고 있는데, 이 변수들은 일반적으로 메모리상에 근접해 있다. 이러한 데이터들은 CPU Cache상에 존재할 가능성이 높고 CPU에서는 캐시 일관성(cache coherence)이라는 메커니즘이 존재한다. 만약 한 쓰레드가 자신의 cell value를 변경할 경우 일관성을 유지하기 위해 다른 쓰레드의 CPU Cache도 계속 업데이트 해야하는 false sharing이 발생할 가능성이 높다.\n\nfalse sharing을 더 자세히 설명하면 다음과 같다.\n\n> False Sharing은 보통 cache coherency protocol에 의해 발생한다. cache는 보통 word 단위가 아닌 block 단위로 데이터를 가져오는데 이것을 cache line이라고 한다.\\\n>  cache line은 보통 64바이트, 128바이트 단위로 모든 작업이 이루어진다. 만약 thread 0에서 사용하는 데이터는 block의 첫 번째 4바이트 뿐이고, thread 1에서도 사용하는 데이터는 마지막 4바이트라고 가정하면 이 둘은 실제 공유하는 데이터가 없지만 같은 cache line에 있기 때문에 어느 한 코어가 데이터에 접근할 때 마다 CPU는 cache가 공유되는 것으로 착각한다.\\\n> 그래서 서로를 invalid 시키는 현상이 일어나게 되고, cache miss를 겪게 된다. 따라서 false sharing은 성능 하락으로 이어질 수 있다.\n\n그래서 이를 해결하기 위해 Striped64 클래스는 cell의 value가 Cache line의 크기가 되도록 padding을 붙이게 된다.\n\n```java\n@jdk.internal.vm.annotation.Contended static final class Cell {\n```\n\nStriped64 클래스의 내부클래스 Cell에 있는 Contended 어노테이션이 padding을 추가하는 역할을 한다.\n\n## 차이점\n\nOracle Java 17 API 문서에서는 각 클래스를 다음과 같이 설명하고 있다.\n\n### LongAdder\n\nLongAdder클래스는 일반적으로 세분화된 동기화 제어가 아닌 통계 수집과 같은 일반적인 합계를 업데이트할 때 AtomicLong보다 선호된다. 낮은 경합에서는 두 클래스가 비슷한 특성을 가지지만 더 많은 경합에서 예상 처리량은 훨씬 높다.\\\n이 클래스는 Number 클래스를 상속 받았고, 객체가 계속 변할 것이라 예상해 equals, hashcode, compareTo 메서드를 정의하지 않았다. 그래서 컬렉션의 key로 유용하지 않다.\n\n### LongAccumulator\n\n스레드 내 또는 스레드 간의 누적 순서는 보장되지 않으며 의존할 수 없으므로 LongAccumulator 클래스는 누적 순서가 중요하지 않은 함수에만 적용할 수 있다. 제공된 accumulator function은 스레드 간의 경합으로 인해 업데이트 시도가 실패할 때 다시 적용될 수 있으므로 부작용이 없어야 한다. 함수는 기존 값을 하나의 인자로 적용하고 주어진 업데이트를 다른 인자로 적용한다. 예를 들어 최대값을 유지하려면 Long.MIN_VALUE와 함께 Long::max를 함수에 제공 함으로 구현할 수 있다.\n\n마찬가지로 Number 클래스를 상속 받았고, 객체가 계속 변할 것이라 예상해 equals, hashcode, compareTo 메서드를 정의하지 않았다. 그래서 컬렉션의 key로 유용하지 않다.\n\n`new LongAdder()`는 `new LongAccumulator((x, y) -> x + y, 0L)`과 같다고 할 수 있다.\n\n```java\nLongAccumulator acc = new LongAccumulator(Long::sum, 0);\n\nacc.accumulate(10);\n```\n\naccumulate(10) 메소드를 호출하면 a[0]에 인자로 받은 10과 생성자의 두번째 인자로 받은 초기값 0이 합쳐져 10+0의 결과가 a[0]에 들어가고,\\\n계속 accumulate 메소드를 호출할수록 a[n]번째에 이처럼 인자+초기값의 결과가 누적된다.\n\n## AtomicLong과 LongAdder 성능 차이\n\n### 업데이트 성능\n\n<P align=\"center\">\n<img src=\"write.png\">\n</p>\n\nAtomicLong의 경우 쓰레드의 개수 증가할수록 성능 하락이 큰폭으로 증가한다. 반면 LongAdder는 쓰레드 개수와 비교해 실행 시간이 증가하지만 총 실행시간 자체가 상대적으로 매우 짧다.\n\n### 읽기 성능\n\n<P align=\"center\">\n<img src=\"read.png\">\n</p>\n\nAtomicLong은 내부에 단일 멤버 변수 하나를 사용하기 쓰레드 개수에 상관없이 읽기 시간이 비등하지만, LongAdder의 경우 쓰레드가 늘어날수록 읽을 때 합산해야하는 값의 개수가 증가하므로 실행시간이 증가한다.\n\n경우에 따라 읽기 작업을 많이 수행하는 상황이면 Atomic 클래스를 사용하고, 쓰기 작업을 많이 수행하는 상황이면 adder나 accumulator를 사용하면될 것 같다.\n"},{"excerpt":"Atomic 자바의 concurrency API에서 제공하는 Atomic Type에 대해 알아보겠다. 멀티 쓰레딩 프로그래밍에서는 기본적으로 동시성 문제를 고려해야되는데, 이러한 문제들을 해결하기 위해 자바에서는 다양한 방법을 제공한다. 대표적으로 Atomic Type, volatile, synchronized가 있다. Atomic Type을 설명하기전에…","fields":{"slug":"/atomic/"},"frontmatter":{"date":"March 02, 2022","title":"Java - Atomic","tags":["java"]},"rawMarkdownBody":"\n## Atomic\n\n자바의 concurrency API에서 제공하는 Atomic Type에 대해 알아보겠다.\\\n멀티 쓰레딩 프로그래밍에서는 기본적으로 동시성 문제를 고려해야되는데, 이러한 문제들을 해결하기 위해 자바에서는 다양한 방법을 제공한다.\\\n대표적으로 Atomic Type, volatile, synchronized가 있다.\n\nAtomic Type을 설명하기전에 원자성의 개념을 알아보자.\n\nAtomic은 한글로 원자라는 의미를 가지고 있고, 원자는 더 쪼갤 수 없는 작은 단위를 의미한다.\nOracle 자바 레퍼선스에서는 Atomic Access를 다음과 같이 정의하고 있다.\n\n> In programming, an atomic action is one that effectively happens all at once.\\\n> An atomic action cannot stop in the middle: it either happens completely, or it doesn't happen at all.\n\n원자적 행위란 사실상 여러가지가 한번에 일어나는 것을 말하는데, 이는 중간에 중지될 수 없고 실행되면 끝까지 실행되던가 아니면 아예 실행되지 않아야 한다고 말한다. 예시를 들어 설명하면 쇼핑몰에서 물건을 주문하는 경우를 말할 수 있다.\n\n결제와 상품 수량 변경은 서로 다른 작업이지만 한 세트로 진행이 되어야 한다. 어떤 상품의 재고가 1개 밖에 없는데 해당 상품을 사려는 고객이 2명이 존재하는 상황을 가정하고 아래와 같은 순서로 요청이 들어오면 어떻게 되는지 살펴보자.\n\n1. 1번 회원의 결제가 성공한다.\n2. 상품 수량의 업데이트가 끝나기전에 2번 회원의 결제도 성공한다.\n3. 상품 수량 업데이트\n4. 상품 수량 업데이트 - 3번의 작업으로 재고는 이미 0이 되었지만 2번 회원은 이미 돈을 지불했는데 재고가 0인 상태다.\n\n현실에서는 이와 같이 많은 사람들이 동시에 동일한 제품을 구매하려는 상황이 부지기수다.\\\n작업이 정상적으로 처리되려면 1번 회원의 결제 결과가 재고에 반영되기 전에 2번 회원의 결제를 잠시 막아둬야하고, 다시 2번 회원의 결제가 시작될 때 재고를 확인하고 재고가 0이라면 결제를 막아야 한다. 비슷한 예시로 수강신청이 있다.\n\n하나의 쓰레드가 모든 작업을 순차적으로 처리하면 이러한 걱정이 없겠지만 사용자는 많은 대기시간을 가지게될 것이다. 그래서 멀티 쓰레드가 사용된다.\\\n이처럼 작업 단위가 분리되면 안되는 연산에 Atomic operation이 필요하고 Java에서 지원해주는 Atomic operation이 Atomic Type, volatile, synchronized 이다.\n\n## Atomic Type\n\n**Atomic Type**을 사용하면 멀티 쓰레드 환경에서 원자성을 보장하는 변수를 선언할 수 있다.\\\nAtomic Type은 내부적으로 CAS(Compare and swap)알고리즘을 통해서 lock 없이 동기화 처리를 한다.\n\n### CAS(Compare and swap)\n\n<p align=\"center\">\n<img src=\"ㅊㅁㄴ.png\">\n</p>\n\n현재 쓰레드에서의 데이터와 실제 메모리에 저장된 데이터를 비교해서 두 개가 일치하면 데이터를 업데이트하고 일치하지 않는다면 재시도를 하게된다.\n\nAtomic 내부에서는 다음과 같이 구현되어있다.\n\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n\n    private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();\n    private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, \"value\");\n    private volatile int value;\n\n    public final int getAndSet(int newValue) {\n        return U.getAndSetInt(this, VALUE, newValue);\n    }\n}\n\npublic final class Unsafe {\n    @HotSpotIntrinsicCandidate\n    public final int getAndSetInt(Object o, long offset, int newValue) {\n        int v;\n        do {\n            v = getIntVolatile(o, offset);\n        } while (!weakCompareAndSetInt(o, offset, v, newValue));\n        return v;\n    }\n\n    @ForceInline\n    public final int getAndSetIntRelease(Object o, long offset, int newValue) {\n        int v;\n        do {\n            v = getInt(o, offset);\n        } while (!weakCompareAndSetIntRelease(o, offset, v, newValue));\n        return v;\n    }\n}\n```\n\n`getAndSet` 메소드는 이전 값을 반환하고 새로운 값을 메모리에 업데이트한다. 메소드의 내부에는 `U(Unsafe)`객체에 역할을 위임하고 Unsafe 클래스의 구현 메소드를 살펴보면 CAS 알고리즘으로 비교값이 true면 값을 반환하고 false면 계속 반복문이 실행되는 것을 볼 수 있다. 많은 메소드가 거의 같은 형태를 가지고 있다.\n\n`value` 맴버는 `volatile` 키워드가 추가되어있는 변수로 CPU캐시가 아닌 메모리에 값을 저장하고 읽어온다. 그래서 가시성 문제가 해결되는데 CAS 알고리즘을 추가적으로 사용하는 이유가 뭘까?\n\n`volatile` 키워드는 오직 한 개의 쓰레드가 읽기/쓰기 작업을 하고 다른 쓰레드는 읽기 작업만 수행할 때 안정성을 보장한다. 그래서 CAS 알고리즘을 추가적으로 적용해 여러 쓰레드에서 일기/쓰기 작업을 할 수 있도록 한다.\n\n## synchronized 와 Atomic type\n\nsynchronized와 Atomic type은 둘 다 동기화 방법인데 차이점은 뭘까??\n\nsynchronized 키워드의 경우 해당 메서드나 블럭에 쓰레드가 접근해 lock을 걸면 lock에 접근하는 다른 쓰레드들은 blocked 상태가 되어 아무 작업도 하지 못하고 기다리게 된다.\n\n반면 Atomic 방식의 경우 non-block 방식으로 true를 반환할 때 까지 계속 반복문을 돌겠지만 쓰레드의 상태를 변경하는 작업이 없고 다른 쓰레드들도 대기시간 없이 각자의 작업을 수행하게 된다. synchronized와 달리 병렬성을 해치지 않으면서 동시성을 보장하기 때문에 더 좋은 성능을 가져올 수 있다.\n\n## synchronized 와 Atomic type의 성능 비교\n\n### synchronized\n\n```java\npublic class TestSynchronized {\n    public int num;\n\n    public TestSynchronized(int num) {\n        this.num = num;\n    }\n}\n\npublic class SynchronizedThread extends Thread{\n\n    boolean operation;\n    TestSynchronized testSynchronized;\n\n    public SynchronizedThread(boolean operation, TestSynchronized testSynchronized) {\n        this.operation = operation;\n        this.testSynchronized = testSynchronized;\n    }\n\n    void add() {\n        synchronized (testSynchronized) {\n            testSynchronized.num++;\n        }\n    }\n\n    void sub() {\n        synchronized (testSynchronized) {\n            testSynchronized.num--;\n        }\n    }\n\n    @Override\n    public void run() {\n        int limit = Integer.MAX_VALUE / 10;\n        for (int index = 0; index < limit; index++) {\n            if (operation) {\n                add();\n            } else {\n                sub();\n            }\n        }\n    }\n}\n```\n\n테스트를 위한 `TestSynchronized` 클래스를 작성하고 `SynchronizedThread` 클래스는 외부에서 전달받은 `testSynchronized` 객체의 `num` 값을 변경 시킨다. `operation`에 따라 증감 연산을 실행한다.\n\n```java\npublic static void synchronizedTest(){\n        long start = System.currentTimeMillis();\n        TestSynchronized testSynchronized = new TestSynchronized(0);\n\n        Thread addThread = new SynchronizedThread(true, testSynchronized);\n        Thread subThread = new SynchronizedThread(false, testSynchronized);\n        try{\n            addThread.start();\n            subThread.start();\n            addThread.join();\n            subThread.join();\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            long end = System.currentTimeMillis();\n            System.out.println(\"operation time: \" + (end - start) + \", value: \" + testSynchronized.num);\n        }\n    }\n```\n\n쓰레드 객체를 생성하고 수행시간과 동시성 제어가 성공했는지 확인한다.\n\n실행 결과\n\n![](rs.png)\n\n약 15초의 수행시간이 걸렸고 동기화가 성공했다.\n\n### Atomic type\n\n```java\npublic class TestAtomic {\n    public AtomicInteger num;\n\n    public TestAtomic(AtomicInteger num) {\n        this.num = num;\n    }\n}\n\npublic class AtomicThread extends Thread{\n    boolean operation;\n    TestAtomic testAtomic;\n\n    public AtomicThread(boolean operation, TestAtomic testAtomic) {\n        this.operation = operation;\n        this.testAtomic = testAtomic;\n    }\n\n    void add() {\n        testAtomic.num.incrementAndGet();\n    }\n\n    void sub() {\n        testAtomic.num.decrementAndGet();\n    }\n\n    @Override\n    public void run() {\n        int limit = Integer.MAX_VALUE / 10;\n        for (int index = 0; index < limit; index++) {\n            if (operation) {\n                add();\n            } else {\n                sub();\n            }\n        }\n    }\n}\n```\n\n변수가 Atomic Type으로 선언된 것 말고는 거의 동일한 코드이다.\n\n```java\npublic static void synchronizedTest(){\n        long start = System.currentTimeMillis();\n        TestSynchronized testSynchronized = new TestSynchronized(0);\n\n        Thread addThread = new SynchronizedThread(true, testSynchronized);\n        Thread subThread = new SynchronizedThread(false, testSynchronized);\n        try{\n            addThread.start();\n            subThread.start();\n            addThread.join();\n            subThread.join();\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            long end = System.currentTimeMillis();\n            System.out.println(\"operation time: \" + (end - start) + \", value: \" + testSynchronized.num);\n        }\n    }\n```\n\n실행 결과\n\n![](rs2.png)\n\n약 7초의 수행시간이 걸렸고 synchronized 방식 보다 2배 이상의 성능이 향상된 것을 확인할 수 있다.\n"},{"excerpt":"쓰레드란?? 이전 포스팅에서 프로세스에 대해 알아보았다. 프로세스는 간단히 설명하면 프로그램이 메모리에 올라가 CPU를 할당받은 실행중인 프로그램이라고 말할 수 있다. 그리고 프로그램을 수행하는데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있으며 이 자원들을 이용해 실제로 작업을 수행하는 실행되는 흐름의 단위를 쓰레드라고 한다. 쓰레드는 …","fields":{"slug":"/thread/"},"frontmatter":{"date":"March 01, 2022","title":"[운영체제(OS)] 3. 쓰레드(Thread)","tags":["운영체제"]},"rawMarkdownBody":"\n## 쓰레드란??\n\n이전 포스팅에서 프로세스에 대해 알아보았다.\\\n프로세스는 간단히 설명하면 프로그램이 메모리에 올라가 CPU를 할당받은 실행중인 프로그램이라고 말할 수 있다. 그리고 프로그램을 수행하는데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있으며 이 자원들을 이용해 실제로 작업을 수행하는 실행되는 흐름의 단위를 **쓰레드**라고 한다.\n\n쓰레드는 lightweight-process라고도 하며 한 번에 하나의 작업만 수행하는 것을 싱글 쓰레드, 하나의 프로세스가 동시에 여러 작업을 수행하는 것을 멀티 쓰레드라고 한다.\n\n<p align=\"center\">\n    <img src=\"thre.png\">\n</p>\n\n여러개의 프로세스가 있을때 각각의 프로세스는 독립적인 메모리 영역을 가진 반면,\\\n쓰레드는 각각 Stack, PC(program counter), registers 영역을 가지고 code, data, heap 영역을 공유한다.\n\n## 멀티쓰레드\n\n그럼 기존의 멀티 프로세스 방식 대신에 멀티쓰레드를 사용할까? 각각에 대해서 간단히 알아보자.\n\n### 멀티 프로세스\n\n각각의 프로세스들은 독립된 메모리 영역을 가진다. 프로세스간 통신하기 위해서는 IPC를 사용해야 한다.\\\n여러개의 프로세스 중에서 하나가 죽어도 다른 프로세스에 영향을 미치지 않는다.\n\n### 멀티 쓰레드\n\n하나의 프로세스가 다수개의 작업을 각각의 쓰레드를 통하여 동시에 실행할 수 있고, 독립적인 프로세스처럼 작업을 수행한다.\\\n대표적인 예시로 웹서버가 있다.\n\n<p align=\"center\">\n    <img src=\"web.png\">\n</p>\n\n클라이언트에서 요청이 오면 서버에서는 쓰레드를 생성해 요청 작업을 수행해서 이 후에 추가되는 요청도 계속해서 받을 수 있다.\n\n멀티 쓰레드의 장점을 정리하면 다음과 같다.\n\n- 쓰레드는 프로세스의 자원을 공유해서 사용하기 때문에 프로세스와 달리 쓰레드간에 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어든다.\n- 멀티 프로세스로 실행되는 작업을 멀티 쓰레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능하다.\n- 프로세스의 문맥 교환에 비해 쓰레드의 문맥 교환은 오버헤드가 더 작다.\n- 확장성이 용이하다.\n\n단점도 존재한다. 위의 내용대로 쓰레드들은 프로세스의 자원을 공유해서 같이 사용하기 때문에 동기화 작업이 이루어지지 않는다면 데이터의 일관성이 문제가 생길 것이다. 또 하나의 쓰레드에 오류가 생기면 같은 프로세스 내의 다른 쓰레드들도 모두 강제 종료가 된다.\n\n## Multicore Programming\n\n멀티코어 시스템을 구현할 때는 동시성(Concurrency)와 병렬성(Parallelism)을 알아야 한다.\\\n동시성은 싱글 코어 시스템에서 사용되는 방식으로, 프로세서가 여러개의 쓰레드를 번갈아가면서 수행함으로 동시에 실행되는 것처럼 보이게 하는 방식이다.\n\n<p align=\"center\">\n    <img src=\"s.png\">\n</p>\n\n시분할을 통해 쓰레드들을 수행하는 모습을 볼 수 있다.\n\n병렬성은 멀티 코어 시스템에서 사용되는 방식으로, 여러개의 코어가 각 쓰레드를 동시에 수행하는 방식이다.\n\n<p align=\"center\">\n    <img src=\"m.png\">\n</p>\n\nparallelism은 data parallelism과 task parallelism 두 가지로 구분할 수 있는데 다음과 같이 말할 수 있다.\n\n- Data: 작업량의 분배 ex) 1~100을 더해야 하는 경우 cpu1는 1~50까지의 데이터를, cpu2는 51~100까지의 데이터를 계산한 후에 합친다.\n- Task: 하는 업무의 분배 ex) 1~50은 더하고, 51~100은 곱해 합산한다. cpu1은 더하는 업무를, cpu2는 곱하는 업무를 수행한 후 합친다.\n\n## User Threads, Kernel Threads\n\n- User Threads: 유저 쓰레드는 커널의 지원없이 관리되는 쓰레드로 POSIX Pthreads, Win32 threads, Java threads 같이 쓰레드 라이브러리를 통해 구현되고 유저가 관리하는 쓰레드이다. 커널 쓰레드에 비해 안정성은 떨어지지만 성능이 저하되지 않는다.\n- Kernel Threads: 커널이 쓰레드 기능은 API형태로 제공하며, 생성된 쓰레드에 대해서 커널이 직접 관리한다. 커널 쓰레드는 안정적이지만 유저 모드에서 커널 모드로 전환이 빈번하게 일어나기 때문에 성능이 저하된다.\n\n## Multithreading Models\n\nMultithreading Models란 유저 쓰레드와 커널 쓰레드의 관계를 설계하는 방법이다. 다음과 같은 방법이 있다.\n\n### Many-to-one model\n\n<p align=\"center\">\n    <img src=\"mo.png\">\n</p>\n\n하나의 커널 스레드에 여러 개의 유저 스레드를 연결하는 모델이다. 한 번에 하나의 유저 스레드만 커널에 접근할 수 있기 때문에 멀티코어 시스템에서 병렬적인 수행을 할 수가 없다. 요즘에는 잘 사용되지 않는 방식이다.\n\n### One-to-one model\n\n<p align=\"center\">\n    <img src=\"oo.png\">\n</p>\n\n하나의 유저 스레드에 하나의 커널 스레드가 대응하는 모델이다. 동시성을 높여주고, 멀티프로세서 시스템에서는 동시에 여러 스레드를 수행할 수 있도록 해준다. 유저 스레드를 늘리면 커널 스레드도 똑같이 늘어나는데, 커널 스레드를 생성하는 것은 오버헤드가 큰 작업이기 때문에 성능 저하가 발생할 수 있다.\n\n### Many-to-many model\n\n<p align=\"center\">\n    <img src=\"mm.png\">\n</p>\n\n여러 유저 스레드에 더 적거나 같은 수의 커널 스레드가 대응하는 모델이다. 운영체제는 충분한 수의 커널 스레드를 만들 수 있으며, 커널 스레드의 구체적인 개수는 프로그램이나 작동 기기에 따라 다르다. 멀티프로세서 시스템에서는 싱글프로세서 시스템보다 더 많은 커널 스레드가 만들어진다.\n"},{"excerpt":"IPC란 프로세스는 독립적으로 실행되거나 서로 협력하면서 실행될 수 있다. 독립적이란 말은 다른 프로세스들과 데이터를 공유하지 않는다는 것이고 반대로 협력적이라는 것은 다른 프로세스들과 데이터를 공유한다는 것이고 다른 프로세스에 영향을 주거나 받을 수 있다. 이때 프로세스들의 통신을 IPC(inter process communication)이라고 한다. …","fields":{"slug":"/process2/"},"frontmatter":{"date":"February 26, 2022","title":"[운영체제(OS)] 2.프로세스-IPC","tags":["운영체제"]},"rawMarkdownBody":"\n## IPC란\n\n<p align=\"center\">\n    <img src=\"process.png\">\n</p>\n\n프로세스는 독립적으로 실행되거나 서로 협력하면서 실행될 수 있다. 독립적이란 말은 다른 프로세스들과 데이터를 공유하지 않는다는 것이고 반대로 협력적이라는 것은 다른 프로세스들과 데이터를 공유한다는 것이고 다른 프로세스에 영향을 주거나 받을 수 있다. 이때 프로세스들의 통신을 IPC(inter process communication)이라고 한다.\n\n## IPC의 통신 방법\n\n특정 프로세스A에서 생산하면(produce) 특정 프로세스B에서 소비하는(consumer) 프로세스의 구조에서 데이터 통신 방법은 두가지가 있다\n\n1. 공유 메모리(Shared Memory)\n2. 메세지 전달(Message Passing)\n\n각각의 통신 방법에 대해 알아보자.\n\n## 공유 메모리(shared memory)\n\n<p align=\"center\">\n    <img src=\"shared.png\">\n</p>\n\n공유 메모리는 프로세스간 특정 메모리 영역을 공유해서 사용할 수 있도록 한다. 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해준다.\\\n이 공유 메모리에 생산자는 buffer를 채우고 소비자는 buffer를 비운다.\n\n공유 메모리 방식은 다른 방식에 비해 속도가 빠르지만 메모리에 접근하고 데이터를 다루는 것을 모두 프로그래머가 명시적으로 코드를 작성해줘야하는 불편함이 있었다.\n\n## 메세지 전달(message passing)\n\n<p align=\"center\">\n    <img src=\"message.png\">\n</p>\n\n메세지 전달 방식은 프로세스간 데이터 통신 수단을 O/S에서 제공해주는 것을 말한다. 생상자는 전송 메소드 send(), 소비자는 응답 메소드 receive()를 사용하고 커널에서 내부 buffer를 관리한다.\\\n메세지 전달 방식은 일반적인 경우 공유 메모리 방식 보다 속도는 느리지만 커널이 기본적인 기능을 제공하므로 공유 메모리 방식보다 구현이 쉬운 점이 있다.\n\n프로세스간 message passing을 위해서 communication links가 만들어지는데 이 links의 구현은 다음과 같은 방식이 있다.\n\n- direct or indirect\n- synchronous or asynchronous\n- automatic or explicit buffering\n\n### direct\n\n프로세스끼리 통신을 하기 위해선 서로를 칭하는 명시적인 이름이 있어야 한다. 이를 다음과 같이 가정할 수 있다.\n\n- sender : message를 보내는 process, send( process_B, message )\n- recipient : message를 받는 process, receive( process_A, message )\n\n이렇게되면 프로세스A와 프로세스B 사이에 link가 하나만 생기게 되고 이렇게 프로세스끼리 직접 link되어 communication 하는 것을 direct communication이라고 한다.\n\n위의 상황같이 발신자와 수신자 둘 다 서로의 이름을 표기하면 **symmentry**라고 하고, 발신자만 이름을 표기하고 수신자는 아무것도 표기하지 않는 것을 **asymmentry**라고 한다. 아래와 같은 경우이다.\n\n`send (process_A, message) -----> receive (message) `\n\ndirect communication 방식은 두 프로세스간에만 데이터를 주고 받을 수 있고, 명시적이기 때문에 하드코딩 되어있다는 단점이 있다.\n\n### indirect\n\n프로세스끼리 직접 communication 하는 것이 아니라 mailbox or port를 통해 message를 주고 받는 것을 indirect communication 이라고 한다.\\\nmailbox는 고유의 id가 있는데 다음과 같이 나타낼 수 있다.\n\n- send(A, message) - mailbox A에게 message를 전달\n- receive(A, message) - mailbox A에게 message를 받음\n\n### synchronous or asynchronous\n\nblocking과 non-blocking 이라고도 하며 동기적으로 구현하는 방식과 비동기적으로 구현하는 방식의 차이가 있다.\n\n|                     |                                                                          |\n| ------------------- | ------------------------------------------------------------------------ |\n| Blocking send       | 수신자 프로세스나 mailbox가 메세지를 받을 때 까지 메세지를 보낼 수 없다. |\n| Nonblocking send    | 발신자 프로세스가 메일을 보내고 다시 자기 일을 한다.                     |\n| Blocking receive    | 메세지가 이용될 수 있을 때까지 아무것도 할 수 없다.                      |\n| Nonblocking receive | 수신자 메세지가 valid한 메세지 혹은 null을 복구한다.                     |\n\n### automatic or explicit buffering\n\nautomatic buffering은 무한한 길이의 큐를 제공하고 explicit buffering은 버퍼의 크기를 명시한다. 구현을 세가지 방법으로 정리하면 아래 표와 같다.\n\n|                    |                                                                                                                                                                                                            |\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| zero capacity      | queue의 buffer가 0이기 때문에 메세지를 보낼 때 마다 block이 된다. 다시 말해, 수신자가 메세지를 받을 때 까지 block된다.                                                                                     |\n| bounded capacity   | queue의 길이가 유한인 n이다. 즉, n개의 메세지만 queue에 push할 수 있다. queue의 buffer가 남았으면 메세지를 보낼 수 있지만, 꽉 차면 block이 된다. 수신자가 메세지를 읽어서 queue가 빌 때까지 기다려야 한다. |\n| unbounded capacity | queue의 길이가 무한대이기 때문에, 발신자는 절대 block되지 않는다.                                                                                                                                          |\n\n## IPC의 예시\n\n그럼 앞서 말한 공유 메모리 방식과 메세지 전달 방식이 어떻게 구현이 되어있는지 알아보자.\n\n### POSIX Shared Memory\n\nmemory-mapped files 방식으로 공유 메모리 객체를 프로세스 메모리에 매핑하는 방식이다.\n\n```c\n/*\ncreate the shared memory object\n*/\nshm_fd = shm_open( O_CREAT O_RDWR, 0666)\n\n/*\nconfigure the size of the shared memory\n*/\nftruncate(shm_fd, SIZE)\n\n/*\nmap the shared memory object\n*/\nptr = (char*)mmap(0, SIZE, PROT_READ PROT_WRITE, MAP_SHARED, shm_fd, 0)\n```\n\n`shm_open`으로 공유 메모리 객체를 생성하고 `ftruncate`로 메모리 공간을 설정한다. 그리고 `mmap`을 통해 매핑을 해서 사용한다.\n\n### Ordinary Pipe\n\nmessage passing의 예시로는 Pipe가 있다. 그중에서 Ordinary Pipe를 알아보겠다.\n\n<p align=\"center\">\n    <img src=\"pipe3.png\">\n</p>\n\nOrdinary Pipe는 두 프로세스가 produce-consumer 관계로 데이터를 주고 받는데, 커뮤니케이션은 단방향 통신이다.\\\n위의 그림은 parant process에서 pipe()로 pipe를 생성하고, fork()로 child process를 생성해 pipe를 통해 데이터를 주고 받는 모습이다.\nfd(0)은 read end를 fd(1)은 write end를 의미한다.\\\n앞서 말한대로 pipe는 단방향 커뮤니케이션이라 했는데 양방향 커뮤니케이션을 하기 위해서는 두 개의 pipe를 만들면 된다.\n\n### Named Pipe\n\n<p align=\"center\">\n    <img src=\"named.png\">\n</p>\n\n앞서 설명한 Ordinary pipe는 두 프로세스가 parent-child 관계를 갖고 있을 때 프로세스가 데이터를 주고 받는 방법에 대한 것이다.\\\nNamde pipe는 이름이 있는 파일을 사용해 parent-child 관계가 아닌 프로세스끼리도 통신을 가능하게 한다. named pipe는 mkfifo 명령어로 생성할 수 있다.\n\n하지만 ordinary pipe와 마찬가지로 단방향 통신이며 쌍방향 통신을 위해서는 pipe를 두 개 생성해줘야 한다.\n\n## client-server 관계의 서로 다른 PC의 프로세스 통신\n\n위의 방식들은 하나의 PC에서의 프로세스 통신 방식이다. 그렇다면 client-server 관계의 서로 다른 PC의 프로세스는 어떻게 데이터를 주고 받을까?\n\n다음과 같은 방법이 있다.\n\n- 소켓(Socket)\n- 원격 프로시저 호출(RPC Remote Procedure Call)\n\n### 소켓(Socket)\n\n<p align=\"center\">\n    <img src=\"socket.png\">\n</p>\n\n소켓은 서로의 endpoint를 특정할 수 있는 IP 주소와 프로세스간의 pipe를 지정하는 port로 이루어져있다. 그래서 이 정보들을 통해서 클라이언트는 네트워크를 통해 서버 프로세스에 접근할 수 있다.\n\nJava의 경우 TCP, UDP, BroadCast를 지원한다.\n\n### 원격 프로시저 호출(RPC Remote Procedure Call)\n\n<p align=\"center\">\n    <img src=\"image.png\">\n</p>\n\n> 원격 프로시저 호출(영어: remote procedure call, 리모트 프로시저 콜, RPC)은 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술이다. 다시 말해, 원격 프로시저 호출을 이용하면 프로그래머는 함수가 실행 프로그램에 로컬 위치에 있든 원격 위치에 있든 동일한 코드를 이용할 수 있다.\n>\n> From wikipedia\n\n현재 유행하는 MSA(Micro Service Architecture) 구조로 서비스를 만들다보면, 다양한 언어와 프레임워크로 개발되는 경우가 많다. 이런 Polyglot한 구조에서는 프로토콜을 맞춰서 통신해야하는 비용이 발생한다. 이러한 경우 RPC를 이용하여 언어에 구애받지 않고, 원격에 있는 프로시저를 호출하여 좀 더 비즈니스 로직에 집중할 수 있게 한다.\n\n위의 설명대로 RPC는 원격지의 프로세스에 접근하여 프로시저 또는 함수를 호출하여 사용한다. 분산 컴퓨팅 환경에서 프로세스 간 상호 통신 및 컴퓨팅 자원의 효율적인 사용을 위해서 발전된 기술이다.\n\n프로시저와 함수의 차이\n\n- 함수는 인풋에 대비한 아웃풋의 발생을 목적으로 한다.\n- 프로시저는 결과 값에 집중하기 보단 '명령 단위가 수행하는 절차'를 목적으로 한다.\n\nRPC의 궁극적인 목표\n\n- 클라이언트-서버 간의 커뮤니케이션에 필요한 상세정보는 최대한 감춘다.\n- 클라이언트는 일반 메소드를 호출하는 것처럼 원격지의 프로지서를 호출할 수 있다.\n- 서버도 마찬가지로 일반 메소드를 다루는 것처럼 원격 메소드를 다룰 수 있다.\n\n## 마치며\n\n이전 포스팅 프로세스의 개념에 이어서 이번 포스팅에서는 IPC에 대해서 알아보았다.\n\n프로세스들이 어떻게 통신을 하는지 자세히 알게되고 이름만 접했던 Socket에 대해서도 더 자세히 알게된 것 같다. RCP는 나중에 따로 포스팅해 더 자세히 다뤄야될 것 같다.\n\n다음은 쓰레드에 대해서 포스팅하겠다.\n"},{"excerpt":"HashMap, HashTable, ConcurrentHashMap의 차이 HashMap, HashTable, ConcurrentHashMap은 모두 Java API 이름이다. HashTable과 HashTable 그리고 ConcurrentHashMap을 정의한다면, '키에 대한 해시 값을 사용하여 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으…","fields":{"slug":"/map/"},"frontmatter":{"date":"February 25, 2022","title":"HashMap, HashTable, ConcurrentHashMap","tags":["java"]},"rawMarkdownBody":"\n## HashMap, HashTable, ConcurrentHashMap의 차이\n\nHashMap, HashTable, ConcurrentHashMap은 모두 Java API 이름이다.\n\nHashTable과 HashTable 그리고 ConcurrentHashMap을 정의한다면, '키에 대한 해시 값을 사용하여 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 associate array'라고 할 수 있다. 이 associate array를 지칭하는 다른 용어가 있는데, 대표적으로 Map, Dictionary, Symbol Table 등이다.\n\n이 셋은 유사한 특징들을 가지고 있지만 세부적으로는 차이점이 존재한다.\n\n각각의 차이점을 알아보자\n\n## Hashtable\n\nHashtable이란 JDK 1.0 부터 있던 Java의 API다.\n\n구현 코드의 일부를 살펴보자.\n\n```java\npublic class Hashtable<K,V>\n    extends Dictionary<K,V>\n    implements Map<K,V>, Cloneable, java.io.Serializable{\n\n    public Hashtable() {\n        this(11, 0.75f);\n    }\n\n    public synchronized int size() {\n        return count;\n    }\n\n    public synchronized V get(Object key) {\n        Entry<?,?> tab[] = table;\n        int hash = key.hashCode();\n        int index = (hash & 0x7FFFFFFF) % tab.length;\n        for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {\n            if ((e.hash == hash) && e.key.equals(key)) {\n                return (V)e.value;\n            }\n        }\n        return null;\n    }\n\n    public synchronized V put(K key, V value) {\n        // Make sure the value is not null\n        if (value == null) {\n            throw new NullPointerException();\n        }\n        // Makes sure the key is not already in the hashtable.\n        Entry<?,?> tab[] = table;\n        int hash = key.hashCode();\n        int index = (hash & 0x7FFFFFFF) % tab.length;\n        @SuppressWarnings(\"unchecked\")\n        Entry<K,V> entry = (Entry<K,V>)tab[index];\n        for(; entry != null ; entry = entry.next) {\n            if ((entry.hash == hash) && entry.key.equals(key)) {\n                V old = entry.value;\n                entry.value = value;\n                return old;\n            }\n        }\n\n        addEntry(hash, key, value, index);\n        return null;\n    }\n}\n```\n\nHashtable 클래스의 대부분의 API를 보면 많은 메소드에 **synchronized** 키워드가 존재하는 것을 볼 수 있다. 메소드 전체가 임계구역으로 설정된다.\n그렇기 때문에 멀티스레스 환경에서 안정성을 보장 받을 수 있다.\n\n하지만 동시에 작업을 하려해도 객체마다 Lock을 하나씩 가지고 있기 때문에 동시에 여러 작업을 해야할 때 병목 현상이 발생할 수 밖에 없다. 메소드에 접근하게 되면 다른 쓰레드는 Lock을 얻을 때까지 기다려야 하기 때문이다.\n\n이런 이유로 Hashtable은 Thread-safe 하다는 특징이 있지만 멀티 스레드 환경에서 사용하기에 느리다는 단점이 있다. 그리고 Java Collections Framework 이전 JDK 1.0 부터 존재하던 API로 하위 호환성을 제공하기 위해 있기 때문에 구현에는 거의 변화가 없다.\n\n또 Key와 Value에 null 값을 허용하지 않고 초기 Capacity가 11이다.\n\n## HashMap\n\n다음은 HashMap을 살펴보겠다.\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n    public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n\n    public V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }\n\n    //보조 해시 함수\n    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n}\n\n```\n\nHashMap은 Java2에서 처음 나온 Java Collections Framework에 속한 API 이다. AbstractMap 추상클래스를 구현하고, Hashtable과 마찬가지로 Map 인터페이스를 구현했기 때문에 제공하는 기능은 같다.\n\nHashtable과 차이점은 보조 해시 함수를 사용하기 때문에 Hashtable에 비하여 해시 충돌이 덜 발생할 수 있어 상대적으로 성능상 이점이 있다. 그리고 초기 capacity가 16인 것을 볼 수 있고, Key와 Value에 모두 Null 값을 허용한다.\n\n```java\n    static final int TREEIFY_THRESHOLD = 8;\n\n    static final int UNTREEIFY_THRESHOLD = 6;\n```\n\n또 차이점은 Separate Chaining의 구현 방식에 있는데 위의 코드 처럼 하나의 버킷에 키-값 쌍의 데이터의 개수가 8개가 되면 링크드 리스트에서 트리로 변경시키고, 데이터를 삭제해 6개가 되면 다시 링크드 리스트로 변경한다. 링크드 리스트 대신 트리를 사용할 수 있도록 Entry 클래스 대신 Node 클래스를 사용한다.\n\nHashMap은 다른 API와 다르게 synchronized가 선언되 있지 않다. 성능은 가장 좋다고 할 수 있지만 Thread-safe 하지 않다. 그래서 멀티스레드의 환경에서 사용하려면 Collections.synchronizedMap(hashMap) 같이 동기화 처리가 필요하다.\n\n## ConcurrentHashMap\n\nConcurrentHashMap은 Hashtable 클래스의 단점을 보완하면서 멀티스레드 환경에서 사용할 수 있도록 만들어진 클래스다.\n\n그럼 어떤 차이가 다른 Map들과 어떤 차이가 있을지 알아보자.\n\n```java\npublic interface ConcurrentMap<K,V> extends Map<K,V>\n\npublic class ConcurrentHashMap<K,V> extends AbstractMap<K,V>\n    implements ConcurrentMap<K,V>, Serializable {\n\n    private static final int DEFAULT_CAPACITY = 16;\n    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;\n\n    static final int TREEIFY_THRESHOLD = 8;\n    static final int UNTREEIFY_THRESHOLD = 6;\n\n    public V get(Object key) {\n        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n        int h = spread(key.hashCode());\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (e = tabAt(tab, (n - 1) & h)) != null) {\n            if ((eh = e.hash) == h) {\n                if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                    return e.val;\n            }\n            else if (eh < 0)\n                return (p = e.find(h, key)) != null ? p.val : null;\n            while ((e = e.next) != null) {\n                if (e.hash == h &&\n                    ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                    return e.val;\n            }\n        }\n        return null;\n    }\n\n    public V put(K key, V value) {\n        return putVal(key, value, false);\n    }\n\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        int hash = spread(key.hashCode());\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f; int n, i, fh; K fk; V fv;\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable();\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))\n                    break;                   // no lock when adding to empty bin\n            }\n            else if ((fh = f.hash) == MOVED)\n                tab = helpTransfer(tab, f);\n            else if (onlyIfAbsent // check first node without acquiring lock\n                     && fh == hash\n                     && ((fk = f.key) == key || (fk != null && key.equals(fk)))\n                     && (fv = f.val) != null)\n                return fv;\n            else {\n                V oldVal = null;\n\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        if (fh >= 0) {\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node<K,V>(hash, key, value);\n                                    break;\n                                }\n                            }\n                        }\n                        else if (f instanceof TreeBin) {\n                            Node<K,V> p;\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                        else if (f instanceof ReservationNode)\n                            throw new IllegalStateException(\"Recursive update\");\n                    }\n                }\n                if (binCount != 0) {\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount);\n        return null;\n    }\n}\n```\n\nConcurrentHashMap은 AbstractMap 추상 클래스를 구현하고 ConcurrentMap 인터페이스를 구현한 것을 볼 수 있다.\n\nHashMap과 마찬가지로 초기 capacity는 16이고, 하나의 버킷에 키-값 데이터가 8개가 되면 트리고 변하고 6개가 되면 다시 링크드 리스트로 변하게 된다.\\\nHashtable처럼 Key와 Value에 null값을 허용하지 않는다.\n\n마찬가지로 ConcurrentHashMap은 Thread-safe한데 Hashtable과 어떤 차이가 있을까?\n\n**synchronized**의 선언부에 차이가 있다. ConcurrentHashMap은 일부 메소드와 그 메소드 내부 일부에만 **synchronized**가 선언되어 있다.\\\n그리고 `private static final int DEFAULT_CONCURRENCY_LEVEL = 16;`처럼 ConcurrentHashMap은 기본적으로 16개의 Lock을 사용해 관리한다.\n\n`putval`의 메소드를 보면 이미 노드가 존재하는 경우(노드가 존재하는 해시 버킷 객체)에만 **synchronized** 를 사용해 하나의 쓰레드만 접근할 수 있도록 제어한다. 서로 다른 쓰레드가 같은 해시 버킷에 접근할 때만 해당 블록이 잠기게 된다.\n\n따라서 메소드 전체에 락을 거는 Hashtable보다 내부에 여러개의 세그먼트를 두고 각 세그먼트마다 별도의 락을 가지고 있는 ConcurrentHashMap이 더 빠르다.\n\n## 마치며\n\nHashMap, HashTable, ConcurrentHashMap의 차이를 간단하게 정리해보면 다음과 같다.\n\n- HashMap은 Thread-safe 하지 않고 Hashtable, ConcurrentHashMap은 Thread-safe하다\n- HashMap은 null 허용하지만 Hashtable, ConcurrentHashMap은 null을 허용하지 않는다.\n- HashMap, ConcurrentHashMap은 초기 capacity가 16이고 하나의 버킷에 데이터의 개수가 8이 넘어갈 경우 linkedList -> tree 구조로 바뀐다. Hashtable은 초기 capacity가 11이다.\n- ConcurrentHashMap이 Hashtable 보다 성능이 좋다.\n\n차이점을 토대로 상황에 따라 적합한 Map을 써야 성능을 낼 수 있을 것 같다.\n\nConcurrentHashMap 빈 해시 버킷에 노드를 삽입 하는 경우,lock을 사용하지 않고 Compare and Swap(cas)을 이용하여 삽입한다는데 cas는 나중에 atomic 클래스를 공부할때 자세히 알아봐야겠다.\n"},{"excerpt":"프로세스란? 프로세스의 정의는 다음과 같다. \"A process is a program in excution\" 실행 중인 프로그램을 프로세스라고 한다. 그럼 프로그램과 프로세스의 차이는 뭘까?? 프로그램: 디스크에 저장되어있는 일련의 명령어들의 집합(.exe같은 파일 시스템에 존재하는 실행파일) 프로세스: 그 프로그램이 메모리에 적재되어 실행중인 프로그램…","fields":{"slug":"/process/"},"frontmatter":{"date":"February 24, 2022","title":"[운영체제(OS)] 1.프로세스","tags":["운영체제"]},"rawMarkdownBody":"\n## 프로세스란?\n\n프로세스의 정의는 다음과 같다.\n\n> \"A process is a program in excution\"\n\n실행 중인 프로그램을 프로세스라고 한다.\n\n그럼 프로그램과 프로세스의 차이는 뭘까??\n\n- 프로그램: 디스크에 저장되어있는 일련의 명령어들의 집합(.exe같은 파일 시스템에 존재하는 실행파일)\n- 프로세스: 그 프로그램이 **메모리**에 적재되어 실행중인 프로그램이 프로세스이다.\n\n<p align=\"center\">\n    <img src=\"process.png\">\n</p>\n\n간단히 말하면 프로그램은 실행중이지 않은, 동작되고 있지 않은 **정적인 개채**라고 할 수 있고 프로세스는 실행중인 **동적인 개채**라고 표현 할 수 있다.\n\n프로세스는 운영체제에서 작업의 단위라 할 수 있고, CPU time, memory, files, I/O devices같은 자원들을 관리할 수 있어야 된다.\n\n프로세스는 다음과 같은 여러개의 섹션의 구조로 되어있다.\n\n<p align=\"center\">\n    <img src=\"memory.png\">\n</p>\n\n- Text section: 명령어 코드, program counter, 프로세스의 레지스터 정보를 같고 있다.\n- Data section: 전역 변수. uninitialized data, initialzied data로 구성되어있다.\n- Heap section: 런타임 동안 동적으로 할당된 메모리 영역\n- Stack section: 함수가 호출될 때 생기는 일시적인 데이터.(function parameter, return address, local variables)\n\n### 프로세스의 상태\n\n프로세스는 다음과 같은 상태를 가지고 있다. 운영체제는 이 상태로 프로세스의 라이프 사이클을 관리하게 된다.\n\n- New: 프로세스가 생성된 상태\n- Running: 프로세스의 명령어를 CPU에 로드해서 실행시키는 상태. 프로세스 수행이 완료되기전에 할당 시간이 끝나면 프로세스는 다시 준비상태로 전이된다.\\\n  준비상태에서 실행상태로의 전이는 **CPU Schedular**에 의해 수행된다(dispatch)\n- Waiting: 이벤트가 발생하여 프로세스가 대기하는 상태(I/O가 완료될 때 까지)\n- Ready: 프로세스가 할당되기까지 대기하는 상태이다.\n  Ready Queue에서 실행을 준비한다.\n- Terminated: 프로세스가 종료되는 상태\n\n<p align=\"center\">\n    <img src=\"life.png\">\n</p>\n\n### PCB(Process Control Block)\n\n그럼 이 프로세스들을 어떻게 관리할까??\n\n운영체제는 프로세스를 제어하기 위해 PCB(Process Control Block)라는 프로세스의 상태 정보를 저장하는 구조체를 사용한다. TCB라고도 불린다.\n\nPCB는 프로세스 상태관리와 **문맥교환**(Context Switch)를 위해 필요하고 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고 프로세스가 완료되면 PCB는 제거된다.\n\nPCB는 다음과 같은 정보를 포함하고 있다.\n\n<p align=\"center\">\n    <img src=\"pcb.png\">\n</p>\n\n- Process ID: PID\n- Process State: 프로세스의 상태 정보\n- Program Counter: 실행될 다음 명령어의 주소\n- Register: Accumulator, CPU Register, General Register 등을 포함한다.\n- CPU Scheduling Information: 우선 순위, 최종 실행시간, CPU 점유시간 등이 포함된다.\n- Memory Management Information: 프로세스의 메모리 위치 정보와 메모리 보호를 위한 경계 레지스터 값, 한계 레지스터 값 등이 저장된다.\\\n  이외에도 세그먼테이션 테이블, 페이지 테이블 등의 정보도 보관한다.\n- Accounting Information: CPU 사용시간과 경과된 시간, 시간제한, 계정 번호 등을 포함한다.\n- I/O status Information: 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.\n\n기본적으로 프로세스란 프로그램이 \"single thread of execution\" 즉 하나의 실행 단위를 수행하는 것 이라고 할 수 있다.\n\n운영체제는 프로세스의 개념을 확장해 한번에 여러 개의 프로세스를 작업할 수 있게 해주고 이를 **multiprocessing**라고 한다.\n\n하지만 시간이 지날수록 프로세스 안에서 single thread of execution으로 관리가 어려워지고 이를 해결하기 위해\n프로세스를 경량화 시킨 thread라는 개념이 나오고 한 프로세스 안에 여러개의 thread가 존재하게 되고 multithread로 작업을 처리하게 된다.\\\nThread는 나중에 다시 포스팅 하겠다.\n\n### Process Scheduling\n\n멀티프로그래밍의 목적은 여러개의 프로세스를 동시에 실행시켜 CPU 사용률의 최대화 시킴에 있다.\n\ntime sharing은 CPU에 할당되는 프로세스를 자주 변경시킴으로 사용자에게 동시에 실행되는 것 처럼 느끼게 하는 것에 목적이 있다.\n\n이를 제대로 이용하기 위해 Scheduling Queus를 사용한다.\n\n<p align=\"center\">\n    <img src=\"queue.png\">\n</p>\n\n- 프로세스가 시스템에 진입할 때, Ready Queue에 들어가게 되고 Dispatch를 통해 CPU에 로드된다.\n- 프로세스는 어떤 이벤트가 발생하면 Wait Queue에 들어가게 된다.\n\n이 큐들은 PCB들의 linked list로 구현된다.\n\n#### Queueing Diagram\n\n<p align=\"center\">\n    <img src=\"ready.png\">\n</p>\n\n위의 Queueing Diagram을 보면 이벤트가 발생함에 따라 프로세스의 wait 상태로 변하고 다시 ready 상태로 변해 대기하는 모습을 보여준다.\n\n### 문맥 교환(Context Switch)\n\n문맥(Context)란 프로세스의 상태 정보를 의미한다.\n\n문맥 교환(Context Switch)은 프로세스의 상태 정보를 교환하는 것이다.\n\n자세히 설명하면 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 이전의 프로세스의 상태를 PCB에 보관하고 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정이다.\n\n<p align=\"center\">\n    <img src=\"switch.png\">\n</p>\n\n문맥 교환의 과정을 보면 위의 그림과 같다.\n\n1. P0 프로세스가 실행 중 interrupt가 발생하면 현재의 상태정보를 PCB0에 저장한다.\n2. PCB1의 정보를 복원해 P1에 제어권이 넘어가고 실행된다.\n3. 다시 interrupt가 발생하면 현재 상태정보를 PCB1에 저장한다.\n4. PCB0의 정보가 복원되고 P0이 실행된다.\n\n## 마치며\n\n프로세스와 문맥교환에 대해서 알아보았다.\n다음 포스팅에서 프로세스에 대해 더 다뤄보겠다.\n"},{"excerpt":"제너릭(Generic) 제너릭(generic)이란 데이터의 타입을 일반화(generalize)한다는 것을 의미한다.  제너릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법이다. 제너릭을 사용하면 다음과 같은 장점을 갖는다. 클새스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다. 반환값에 대한 타입 변환 및…","fields":{"slug":"/generic/"},"frontmatter":{"date":"February 20, 2022","title":"제너릭(Generic)","tags":["java"]},"rawMarkdownBody":"\n## 제너릭(Generic)\n\n제너릭(generic)이란 데이터의 타입을 일반화(generalize)한다는 것을 의미한다. \\\n제너릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법이다.\n\n제너릭을 사용하면 다음과 같은 장점을 갖는다.\n\n1. 클새스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다.\n2. 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.\n3. 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.\n\n예를 들면 여러 타입을 사용하는 클래스나 메소드에서 인수나 반환 값으로 Object 타입을 사용한다 했을 때 반환된 Object 객체를 사용하려면 원하는 타입으로 타입 변환 해야되고, 이때 오류가 발생할 가능성도 존재한다. `instanceof` 예약어를 사용해 타입을 점검해가면서 타입 변환을 할 수 있지만 번거로운 작업이 될 것이다.\n\nOracle에서 제너릭을 설명하는 간단한 예제를 보자.\n\n```java\n/**\n * Generic version of the Box class.\n * @param <T> the type of the value being boxed\n */\npublic class Box<T> {\n    private T t;\n\n    public void set(T t) { this.t = t; }\n    public T get() { return t; }\n}\n```\n\n클래스 이름 옆의 <>의 parameter는 type parameter이며 type variable이라고 부르기도 한다. \\\nJava7 이후부터 Diamond로 부르기도 한다.\n\n위의 Box 클래스에서 모든 Object의 생성은 T로 대체된다.\n\ntype variable은 class, interface, array 등등의 non-primitive type은 어떤 것이든 가능하다.\n\n## 제네릭 타입\n\n| 타입  |                  설명                   |\n| :---: | :-------------------------------------: |\n|   E   | 요소(Element, Collection에서 주로 사용) |\n|   T   |                  타입                   |\n|   K   |                   키                    |\n|   V   |                   값                    |\n|   N   |                  숫자                   |\n| S,U,V |  두번째, 세번째, 네번째에 선언된 타입   |\n\n제네릭 타입은 Value 같이 임의의 어떤 단어로 선언해도 상관없지만 자바에서 정의한 기본 규칙은 위의 표 처럼 되어있다.\n누가 보더라도 쉽게 이해할 수 있도록 하려면 규칙을 따르는 것이 좋다.\n\n## 제네릭의 형태\n\nJava에서 제공하는 제너릭에는 다음과 같은 형태가 있다.\n\n- 매개변수화 타입(Parameterized type)\n- 언바운드 와일드카드 타입(Unbounded wildcard type)\n- 바운드 타입 매개변수(Bounded type parameter)\n- 재귀적 타입 바운드(Recursive type bound)\n- 제네릭의 서브타이핑(Subtyping in generics)\n- 와일드카드 서브 타이핑(Wildcard and subtyping)\n- 바운드 와일드카드 타입(Bounded wildcard type)\n- 제네릭 메소드(Generic method)\n\n---\n\n### 매개변수화 타입(Parameterized type)\n\n하나 이상의 타입 매개변수를 선언하고 있는 클래스나 인터페이스를 제네릭 클래스, 제네릭 인터페이스라고 하며 이를 합쳐 제네릭 타입이라고 한다.\n각 제네릭 타입에서는 매개변수화 타입들을 정의하는데 다음과 같은 것이다.\n\n```java\nList<Integer> list = new ArrayList<>();\n```\n\n<>안에 있는 Integer를 **실 타입 매개변수**라고 하며 `List<E>`의 E를 **형식 타입 매개변수**라고 한다. 제네릭은 **타입 소거자**에 의해 자신의 타입 요소정보를 삭제한다.\n\n`E, List<E>, List<String>`과 같은 타입들을 비 구체화 타입이라고 하고 그 반대로 구체화 타입이 있으며, ```List<?>, Map<?,?>와 같은 언바운드 와일드 카드 타입 등이 있다.\n\n> 비 구체화 타입(non-reifiable type): 타입 소거자에 의해 컴파일 타임에 타입 정보가 사라지는 것(런타임에 구체화 하지 않는 것)\n>\n> 구체화 타입(reifiable type): 자신의 타입 정보를 런타임 시에 알고 지키게 하는 것(런타임에 구체화 하는 것)\n\n### 언바운드 와일드카드 타입(Unbounded wildcard type)\n\n`List<?>`와 같은 타입을 언바운드 와일드 카드 타입이라고 한다.\\\n해석해보면 어떤 타입이 오든 관계가 없다는 것이다.\n\n예제코드를 살펴보자.\n\n```java\npublic static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        list.add(1);\n        list.add(1000);\n        list.add(2000);\n\n        printListWildcard(list);\n    }\npublic static void printListWildcard(List<?> list){\n    for (Object o : list) {\n        System.out.println(o);\n    }\n}\npublic static void printListInteger(List<Integer> list) {\n    for (Integer o : list) {\n        System.out.println(o);\n    }\n}\n\npublic static void printListString(List<String> list) {\n    for (String o : list) {\n        System.out.println(o);\n    }\n}\n```\n\nlist의 객체를 하나씩 출력하는 함수다. 예제와 같이 제네릭의 타입 매개변수에 따라 메소드가 만들어지는 것을 볼 수 있다. 타입이 두 세개로 한정되있다면 메소드를 일일이 작성할 수 있겠지만 타입이 늘어날 수록 간단한 출력 메소드를 계속 작성하는 것은 매우 비효율 적이다.\n\n그래서 <?> 같이 적어주면 어떤 타입이 제네릭 타입이 되어도 상관 없게 된다.\n\n언바운드 와일드 타입이 사용될수 있는 경우는 다음과 같다.\n\n1. Object 클래스에서 제공되는 기능을 사용하여 구현할 수 있는 메서드를 작성하는 경우.\n2. 타입 파마리터에 의존적이지 않는 일반 클래스의 메소드를 사용하는 경우, `List.clear, List.size ....`\n\n### 바운드 타입 매개변수(Bounded type parameter)\n\n바운드 타입은 특정 타입으로 제한한다는 의미이다. 클래스나 인터페이스 설계 시 흔하게 사용한다.\n\n예제 코드를 살펴보자\n\n```java\npublic class Box <T extends Number>{\n    private T value;\n\n    public void setValue(T value) {\n        this.value = value;\n    }\n}\n\npublic class BoxSample {\n    public static void main(String[] args) {\n        Box<Double> box = new Box<>();\n        box.setValue(1.0);\n        box.setValue(\"st\");\n        Box<Integer> box2 = new Box<>();\n        box2.setValue(1);\n\n        Box<String> box3 = new Box<>();\n    }\n}\n```\n\nBox 클래스의 타입으로 Number의 서브타입만 허용한다는 의미다. Wrapper 클래스는 추상클래스 Number를 상속받아 구현한 클래스이다.\\\n그래서 Box 객체를 생성할때 String타입으로 선언할 때와, Double타입의 box에 다른 타입의 값을 set할 때 컴파일 에러가 발생한다.\n\n다중 바운드 타입이라는 것도 존재한다. 다중 바운드 타입은 하나의 클래스와 여러개의 인터페이스를 선언할 수 있다.\n\n```java\nclass A{}\ninterface B{}\ninterface C{}\n\nclass D<T extends A & B & C> {\n\n}\n```\n\n### 재귀적 타입 바운드(Recursive type bound)\n\n재귀적 타입 바운드는 타입 매개변수가 자신을 포함하는 수식에 의해 한정될 수 있다. 타입의 자연율을 정의하는 `Comparable` 인터페이스와 가장 많이 사용된다.\n\n> 자연율: 상식적인 관점에서 알 수 있는 순서를 말하며, 문자열은 알파벳 순으로, 숫자는 크기순으로 정해진다.\n\n`Comparable` 인터페이스를 살펴보면 다음과 같다.\n\n```java\npublic interface Comparable<T> {\n\n    public int compareTo(T o);\n}\n```\n\n타입 매개변수 T는 자신과 비교될 수 있는 요소를 정의한 것이다. `Comparable`을 구현하는 요소들의 목록을 정렬하거나, 최소,최댓값을 구하는 작업을 하기 위해서는 요소들이 서로 비교가 가능해야 한다.\\\n\n아래 코드는 최댓값을 구하는 코드이다.\n\n```java\nstatic <T extends Comparable<T>> T max(List<T> list) {\n    Iterator<T> iterator = list.iterator();\n    T result = iterator.next();\n    while (iterator.hasNext()) {\n        T t = iterator.next();\n        if (t.compareTo(result) > 0) result = t;\n    }\n\n    return result;\n}\n```\n\n`<T extends Comparable<T>>`는 \"자신과 비교될 수 있는 모든 타입 T\"라고 읽을 수 있다.\n\n### 제네릭의 서브타이핑(Subtyping in genrics)\n\n```java\nBox<Number> box = new Box<>();\nbox.setValue(Integer.valueOf(10));\nbox.setValue(Double.valueOf(101.1));\n```\n\n`Box`클래스의 매개변수화 타입을 Number로 선언했고 `Integer, Double`은 서브타입이기 때문에 문제가 없다.\n하지만 아래의 코드에서는 컴파일 에러가 발생한다.\n\n```java\npublic static void boxTest(Box<Number> box) {\n        System.out.println(box);\n    }\nboxTest(new Box<Number>());\nboxTest(new Box<Integer>());\n```\n\n왜나하면 `Box<Integer>`는 `Box<Number>`의 서브타입이 아니기 때문이다.\n\n<p align=\"center\">\n    <img src=\"dia.jpg\">\n</p>\n\n매개변수화 타입은 **무공변**이기 때문에 `Box<Number>`에서는 Number 타입만 허용하고 `Box<Integer>`에서는 Integer 타입만 혀용한다. 그래서 둘은 다른 존재다.\\\n제네릭 클래스나 인터페이스를 상속관계로 정의하고 싶으면 다음 그림과 같이 상속 관계를 정의해야 한다.\n\n<p align=\"center\">\n    <img src=\"inter.png\">\n</p>\n\n```java\ninterface PayloadList<E,P> extends List<E>{\n    void setPayload(int index, P val);\n}\n```\n\n`PayloadList`는 `List<E>`를 상속받으며 타입 P를 추가적으로 선언했다.\\\n그래서 `PayloadList`는 다음과 같은 형태를 가질수 있게 된다.\n\n- PayloadList <String, String>\n- PayloadList <String, Integer>\n- PayloadList <String, Exception>\n\n<p align=\"center\">\n    <img src=\"result.gif\">\n</p>\n\n### 와일드카드 서브타이핑(wildcard and subtyping)\n\n위의 경우를 다음과 같이 바운드 와일드카드 타입을 이용해서 Number의 서브타입을 같는 Box를 전달할 수 있다.\n\n```java\npublic static void boxTest(Box<? extends Number> box) {\n        System.out.println(box);\n    }\nboxTest(new Box<Number>());\nboxTest(new Box<Integer>());\n```\n\n### 바운드 와일드카드 타입(Bounded wildcard type)\n\n바운드 와일드 타입에는 2가지가 있다\n\n- Upper bounded wildcard: `<? extends T>` **공변(covariant)** 아라고도 한다.\n- Lower bounded wildcard: `<? super T>` **반공변(contravariance)** 이라고도 한다.\n\nextends-bound, super-bound는 **PECS** (Producer-extends, Consumer=super)라는 개념으로도 사용된다.\n\n```java\nclass Box{\n\n}\nclass Package extends Box{\n\n}\n\npublic static void test1(List<? extends Box> list){\n    Box box = list.get(0);\n    list.add(new Box()); //compile error\n}\n\npublic static void test2(List<? super Box> list){\n    Box box = list.get(0); //compile error\n    list.add(new Box());\n}\n```\n\n위의 코드를 보면 Producer-extends는 읽기만 가능하고 Consumer-super는 쓰기만 가능한 것을 알 수 있다.\\\nOracle 문서에서는 In,Out 개념으로 가이드하고 있다. `copy(src, dest)라는 메소드가 있다고 가정하면 src는 복사할 데이터를 제공하므로 생산In 인자가 되고, dest는 다른곳에서 사용할 데이터를 받으므로 소비 Out 인자가 되므로 In의 경우 extends, Out의 경우는 super 키워드를 사용한다.\n\n### 제네릭 메서드(Generic method)\n\n메서드에도 마찬가지로 제네릭을 적용할 수 있다.\n\n```java\npublic static void addItem(Box<?> box, int v) {\n    box.setValue(v);\n}\n```\n\n위의 코드는 인자 box에 인자 v의 값으로 변경 시키려는 메서드다. 하지만 와일드 카드를 사용할 경우 타입 매개변수마다 v의 타입이 맞아야 되기 때문에 컴파일 애러가 발생한다. <?>를 v 매개변수의 타입과 맞춰서 메서드를 작성할순 있지만 이 경우 많은 반복적인 코드를 작성해야된다.\n\n이럴때 제네릭 메소드를 적용하면 해결 할 수 있다.\n\n```java\npublic static <T> void addItem(Box<T> box, T v) {\n    box.setValue(v);\n\npublic static void main(String[] args) {\n    Box<String> box2 = new Box<>();\n    //BoxSample.<String>addItem(box2,\"10\");\n    BoxSample.addItem(box2,\"10\");\n}\n```\n\n`BoxSample.<String>addItem(box2,\"10\")` 처럼 매개변수화 타입을 정의해줘야 하지만 타입 추론에 의해 생략 가능하다.\n\n제네릭 메서드 또한 바운드 와일드카드를 적용할수 있다.\n\n```java\npublic static <T extends Number> void addItem(Box<T> box, T v) {\n    box.setValue(v);\n}\n\npublic static <T,S extends Number> void addItem(Box<T> box, T v, S v2) {\n    box.setValue(v);\n}\n```\n\n위의 예제같이 작성이 가능하고, 하나 이상의 제네릭 타입 선언은 콤마로 구분하여 나열하면 된다.\n"},{"excerpt":"HashMap","fields":{"slug":"/hashmap/"},"frontmatter":{"date":"February 19, 2022","title":"HashMap","tags":["Java"]},"rawMarkdownBody":"\n## HashMap\n"},{"excerpt":"문제 문자열 중복 확인 문자열이 주어졌을 때, 이 문자열에 같은 문자가 중복되어 등장하는지 확인하는 알고리즘을 작성하라. 나의 첫 풀이 문자열 \"abcda\"가 주어졌을 때 'a'가 중복되므로 false를 반환하고 \"abcd\"가 주어지면 중복이 없으므로 true를 반환하면 된다. 부끄럽지만 내가 처음에 짠 코드는 다음과 같다. 입력 받은 문자열을 char …","fields":{"slug":"/string/"},"frontmatter":{"date":"February 17, 2022","title":"문자열 중복 ","tags":["알고리즘"]},"rawMarkdownBody":"\n## 문제\n\n문자열 중복 확인\n\n문자열이 주어졌을 때, 이 문자열에 같은 문자가 중복되어 등장하는지 확인하는 알고리즘을 작성하라.\n\n## 나의 첫 풀이\n\n문자열 \"abcda\"가 주어졌을 때 'a'가 중복되므로 false를 반환하고 \"abcd\"가 주어지면 중복이 없으므로 true를 반환하면 된다.\n\n부끄럽지만 내가 처음에 짠 코드는 다음과 같다.\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String st=br.readLine();\n        System.out.println(isDuplicated(st));\n    }\n\n    public static boolean isDuplicated(String string) {\n        char[] chars = new char[string.length()];\n        string.getChars(0, string.length(), chars, 0);\n\n        for (int i = 0; i < chars.length; i++) {\n            char value = chars[i];\n            for (int j = 0; j < chars.length; j++) {\n                if (i == j) {\n                    continue;\n                }else if(value==chars[j]){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n1. 입력 받은 문자열을 char 배열로 변환시킨다.\n2. 첫 번째 for문에서는 배열의 내용과 비교할 값을 뽑아낸다.\n3. 다음 for문에서 뽑아낸 값의 인덱스 i와 비교하고자 하는 배열의 인덱스 j가 같으면 continue로 건너뛰고 다음 비교에서 같은 값이 찾아지면 false를 반환한다.\n\n물론 원하는 결과를 얻을 순 있지만 간단히 보기만해도 비효율적인 코드라는 것이 느껴진다...\n\n## 풀이 2\n\n문자열이 ASCII 문자열이라고 가정해 보자. 아스키 문자열은 1비트는 에러 확인을 위한 parity bit로 사용하고, 그리고 나머지 7비트로 총 128개의 부호를 나타낸다. 그러면 문자열의 길이가 128이 넘어가게되면 당연히 중복된 문자가 있을 수 밖에 없다. 그리고 `'A' = 65 'B' = 66`같이 고유의 정수 값을 가지고 있다. 이를 토대로 코드를 작정하면 다음과 같다.\n\n```java\npublic static boolean isDuplicated(String string){\n        if (string.length()>128) return false;\n        boolean[] check = new boolean[128];\n        for (int i = 0; i < string.length(); i++) {\n            int val = string.charAt(i);\n            if (check[val]) {\n                return false;\n            }\n            check[val] = true;\n        }\n        return true;\n    }\n```\n\n1. 문자열의 길이가 128을 넘어가면 false를 반환한다.\n2. 문자열의 길이만큼 반복문을 돌며 해당 값이 이미 존재하는지 확인한다.\n\n아스키 문자열이라고 가정하는 것 하나로 코드가 간단해졌다.\n이 코드의 시간 복잡도는 O(n)이다. (n은 문자열의 길이)\n\n## 풀이 3\n\n비트 벡터를 사용하면 필요한 공간을 줄일 수 있다. 문자열이 소문자 a부터 z까지라고 가정한다.\na부터 z까지의 문자는 총 26개이다.\n\n```java\npublic static boolean isDuplicated(String string){\n    int checker = 0;\n    for (int i=0; i<string.length(); i++){\n        int val = string.charAt(i) - 'a';\n        if((checker & (1<<val))>0){\n            return false;\n        }\n        checker |= (1<<val);\n    }\n    return true;\n}\n```\n\n1. 만약 `string.charAt(i) = 'a'`라면 `val = 0`, `string.charAt(i) = 'b'` 라면 `val=1`....라고 할 수 있다. 따라서 val는 0에서 25까지의 정수 값이 될 수 있다.\n2. `1<<val`는 1을 val 만큼 왼쪽 시프트 연산하여 해당 알파벳을 비트 값으로 표현한다. 연산 후의 값은 `a = .... 0001`, `b = .... 0010`, `g = .... 0100 0000`이 된다.\n3. `if((checker & (1<<val))>0)` 조건문에서는 checker와 알파벳 비트값을 AND 연산하여 값의 중복여부를 판단한다.\n4. `checker |= (1<<val);` OR 연산으로 해당 알파벳의 비트 값을 1로 조정한다.\n\n---\n\n### 결론\n\n다양한 풀이를 알아보았다. 내가 처음에 풀었던 코드는 너무 형편없지만 꾸준히 문제를 풀어나가면 더 효율적인 방법을 찾고 새로운 시각으로 문제를 풀어나갈 수 있을 것이라 기대한다...\n"},{"excerpt":"String Constant Pool  의 두가지 생성 방식이 있고 각각의 차이점이 있다.  를 이용한 생성 방식 리터럴을 이용한 생성 방식 두 가지 방식의 큰 차이점은  연산자로 String 객체를 생성하면 Heap 영역에 객체를 저장하고, 리터럴로 String 객체를 생성하면 내부적으로 메소드가 호출되고 String Constant Pool 이라는 영…","fields":{"slug":"/stringPool/"},"frontmatter":{"date":"February 14, 2022","title":"String Pool","tags":["java"]},"rawMarkdownBody":"\n## String Constant Pool\n\n`String` 의 두가지 생성 방식이 있고 각각의 차이점이 있다.\n\n1. `new` 를 이용한 생성 방식\n2. 리터럴을 이용한 생성 방식\n\n두 가지 방식의 큰 차이점은 `new` 연산자로 String 객체를 생성하면 Heap 영역에 객체를 저장하고, 리터럴로 String 객체를 생성하면 내부적으로 `String의 intern()`메소드가 호출되고 **String Constant Pool** 이라는 영역에 존재하게 된다. String Constant Pool 영역은 Heap 영역 내부에서 String 객체를 관리 위해 별도로 공간이 제공되고 있다. 이 공간에 문자열을 저장하고 사용하는 것을 **String Interning**이라고 한다.\n\nString Interning은 다음의 흐름으로 값을 찾는다.\n\n1. String 값이 String Constant Pool에 있는지 찾는다.\n2. 있다면 그 문자열 객체의 주소 값을 반환한다.\n3. 값이 없다면 String Constant Pool에 해당 값의 String 객체를 생성하고 주소 값을 반환한다.\n\nString Constant Pool을 이용하면 같은 값은 메모리에 추가 할당 없이 재사용이 가능하다는 장점을 가지고 있다.\n\n```java\npublic class StringPoolTest {\n    public static void main(String[] args) {\n        String s1 = new String(\"hello\");\n        String s2 = new String(\"hello\");\n\n        String s3 = s1.intern();\n        String s4 = \"hello\";\n        String s5 = \"hello\";\n\n        System.out.println(\"s1 :\"+s1.hashCode());\n        System.out.println(\"s3 :\"+s3.hashCode());\n        System.out.println(\"s4 :\"+s4.hashCode());\n\n        System.out.println(\"s1 :\"+System.identityHashCode(s1));\n        System.out.println(\"s2 :\"+System.identityHashCode(s2));\n        System.out.println(\"s3 :\"+System.identityHashCode(s3));\n        System.out.println(\"s4 :\"+System.identityHashCode(s4));\n        System.out.println(\"s5 :\"+System.identityHashCode(s5));\n\n        System.out.println(s1==s2);\n        System.out.println(s3==s4);\n        System.out.println(s1.equals(s3));\n\n    }\n}\n```\n\n실행 결과\n\n![](result.png)\n\neqauls,==에 대한 포스팅은 [eqauls와 ==의 차이](https://hojoon7807.github.io/equals/) 포스팅을 보면 된다.\n\n실행 결과를 보면 new() 연산자로 생성된 객체 s1,s2는 같은 문자열값을 가지지만 주소값이 다른 것을 확인 할 수 있다. s3는 intern() 메소드를 사용하여 `\"hello\"`가 위에서 설명한 흐름을 통해 String Constant Pool 영역에 값이 생성된 것을 확인 할 수 있다. 그래서 s3, s4도 위의 결과를 가진다.\nhashCode()의 결과가 모두 같은 이유는 String에 오버라이딩된 코드를 보면 문자열의 값을 이용해 hash 값을 생성하기 때문에 그렇다.\n\n## Java 버전에 따른 String Constant Pool의 변화\n\n### Java 6 이전\n\nJava 6 이전에서는 String Constant Pool은 PermGen(Permenent Generation)영억에 있었다. 하지만 PermGen은 사이즈가 고정된 영역이었기 때문에 많은 String 데이터를 사용하면 OOM(Out Of Memory) 문제를 발생시킬수 있었다.\n\n### Java 7\n\nJava 7 버전으로 올라오면서 String Constant Pool은 Heap 영역으로 위치가 옮겨졌다. 더 이상 고정된 크기의 메모리 영역에 제한을 받지 않게 됐다.\n또 String Constant Pool의 모든 문자열도 **GC(Garbage Collection)**의 대상이 된다.\n\n## StringTableSize\n\nString Constant Pool은 기본적으로 해시테이블 구조를 가지고 있다. String을 해싱하고 그것을 키로 하여 값을 찾기 때문에 좋은 성능을 발휘할 수 있다. 해시테이블의 버킷 크기는 Java 버전 마다 차이가 있고 크기는 변경이 가능하다.\n"},{"excerpt":"equals 와 == equals 와 == 연산자는 기본적으로 양 쪽의 내용을 비교한 결과를 boolean type으로 반환한다는 공통점을 가지고 있다. ==연산자 == 연산자는 피 연산자가 기본 자료형 타입일 경우 값이 같은지 비교하고, 피연산자가 그 외 객체 참조 타입인 경우 주소값을 비교한다. 위의 예제를 보면 기본자료형 타입은 값을 비교하기 때문에…","fields":{"slug":"/equals/"},"frontmatter":{"date":"February 10, 2022","title":"equals와 ==","tags":["java"]},"rawMarkdownBody":"\n## equals 와 ==\n\nequals 와 == 연산자는 기본적으로 양 쪽의 내용을 비교한 결과를 boolean type으로 반환한다는 공통점을 가지고 있다.\n\n### ==연산자\n\n== 연산자는 피 연산자가 기본 자료형 타입일 경우 값이 같은지 비교하고, 피연산자가 그 외 객체 참조 타입인 경우 주소값을 비교한다.\n\n```java\n    int num1 = 1;\n    int num2 = 1;\n    int num3 = 3;\n    System.out.println(num1==num2); //true\n    System.out.println(num1==num3); //false\n\n    String str1 = \"HI\";\n    String str2 = \"HI\";\n    System.out.println(str1==str2); //true\n\n    String str3 = new String(\"HI\");\n    String str4 = new String(\"HI\");\n    System.out.println(str3==str4); //false\n    System.out.println(str3==str2); //false\n\n    Person person = new Person(0, \"hojoon\");\n    Person person2 = new Person(0, \"hojoon\");\n    System.out.println(person==person2); //false\n```\n\n위의 예제를 보면 기본자료형 타입은 값을 비교하기 때문에 true와 false를 반환한 것을 볼 수 있다.\n\nString 타입인 경우 결과가 좀 특이한 것을 볼 수 있는데 이것은 생성 방식에 따른 차이이다.\nnew를 이용해 객체를 생성하면 Heap 영역에 존재하게 되고 리터럴을 이용해 객체를 생성하면 String pool이라는 영역에 존재하게 된다. 그래서 str1은 HI라는 문자열을 String pool에 넣게되고 str2는 이미 같은 문자열이 String pool에 존재하기 때문에 같은 객체를 참조하게 된다.\n따라서, `str1==str2 // true`, `str3==str4 //false`, `str2==str3 //false`라고 결과가 나온다.\nString pool은 나중에 더 자세히 다뤄보자.\n\n### equals()\n\n위의 예제에서 `person`과 `person2`는 다른 객체이기 때문에 주소값이 다르지만 그 안의 속성값들은 같다. 이 같은 경우 처럼 eqauls() 메소드는 비교하고자 하는 객체의 내용을 비교하기 위해 사용한다.\n\n```java\n//Object\n\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\nObject 클래스에는 단순하게 주소값을 비교하게 해놨다. 모든 Object의 자식 클래스이므로 해당 클래스에서 equals() 메소드를 오버라이딩해서 구현하면된다. 사용하는 IDLE의 기능을 이용하면 다음과 같이 구현된다.\n(읽고있는 책에서는 기본적으로 hashCode()메소드는 객체의 주소를 16진수로 리턴하고 equals()를 오버라이딩하지 않으면 hashCode()값을 비교한다해서 hashCode를 오버라이딩해서 확인을 해봤더니 false가 나왔다. Object의 hashcode()는 주소를 리턴한다는 것을 주소값을 비교한다는 의미로 써있는건지 잘 모르겠다...)\n\n```java\npublic class Person {\n    private int id;\n    private String name;\n\n    public Person(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Person person = (Person) o;\n\n        if (id != person.id) return false;\n        return name != null ? name.equals(person.name) : person.name == null;\n    }\n}\n```\n\n이제 equals() 메소드를 이용해 비교를 해보면 다음의 결과가 나온다.\n\n```java\npublic class Equals {\n    public static void main(String[] args) {\n        String str1 = \"HI\";\n        String str2 = \"HI\";\n        System.out.println(str1.equals(str2)); //true\n\n        String str3 = new String(\"HI\");\n        String str4 = new String(\"HI\");\n        System.out.println(str3.equals(str4)); //true\n        System.out.println(str3.equals(str1)); //true\n\n        Person person = new Person(0, \"hojoon\");\n        Person person2 = new Person(0, \"hojoon\");\n        System.out.println(person.equals(person2)); //true\n    }\n}\n```\n\n그런데 String은 따로 equals()를 작성하지 않았는데 어떻게 true를 반환하게 되는걸까? String 클래스에서 확인해보면 자체적으로 값을 비교하게 equals() 메소드를 오버라이딩 해놓은 것을 볼 수 있다.\n\n```java\n//String.java\n\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String aString = (String)anObject;\n        if (coder() == aString.coder()) {\n            return isLatin1() ? StringLatin1.equals(value, aString.value)\n                              : StringUTF16.equals(value, aString.value);\n        }\n    }\n    return false;\n}\n```\n\n그런데, 한 가지 유념해야 될 부분은 equals() 메소드를 오버라이딩 할때는 hashCode() 메소드도 같이 오버라이딩 해야된다. hashCode() 메소드는 기본적으로 객체의 메모리 주소값을 16진수로 리턴한다. 그래서 equal() 메소드를 재정의해서 객체가 서로 같다고 할 수는 있지만 주소값은 서로 다르기 때문에 hashCode() 메소드의 값은 다르게 된다.\n따라서 같은 hashCode() 결과를 갖도록 하려면 equals와 마찬가지로 오버라이딩 해줘야된다.\n\n```java\npublic class Person {\n    private int id;\n    private String name;\n\n    public Person(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Person person = (Person) o;\n\n        if (id != person.id) return false;\n        return name != null ? name.equals(person.name) : person.name == null;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = id;\n        result = 31 * result + (name != null ? name.hashCode() : 0);\n        return result;\n    }\n}\n\n```\n\nString은 equals와 마찬가지로 이미 구현이 되어있다.\n\n```java\n//String.java\n\npublic int hashCode() {\n    int h = hash;\n    if (h == 0 && value.length > 0) {\n        hash = h = isLatin1() ? StringLatin1.hashCode(value)\n                              : StringUTF16.hashCode(value);\n    }\n    return h;\n}\n```\n\n### 만약 hashCode()를 재정의 하지 않았다면..\n\n만약 hashCode()를 재정의 하지 않았다면 어떤 부작용이 생길 수 있을까??\n\nhashCode()를 재정의 하지 않은 같은 두 객체를 HashSet에 넣는다고 가정해보자.\n\n```java\npublic class Equals {\n    public static void main(String[] args) {\n        Person person = new Person(0, \"hojoon\");\n        Person person2 = new Person(0, \"hojoon\");\n        System.out.println(person.equals(person2)); //true\n        System.out.println(person.hashCode()); // 1456208737\n        System.out.println(person2.hashCode()); // 288665596\n\n        Set<Person> personSet = new HashSet<>();\n        personSet.add(person);\n        personSet.add(person2);\n\n        for(Person tmp:personSet){\n            System.out.println(tmp);\n        }\n        //p.Person@1134affc\n        //p.Person@56cbfb61\n        System.out.println(personSet.size()); // 2\n    }\n}\n```\n\n다음과 같이 personSet의 사이즈가 2가 나왔다.\n\n```java\n//HashSet.java\n\npublic class HashSet<E>\n    extends AbstractSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable\n{\n    static final long serialVersionUID = -5024744406713321676L;\n\n    private transient HashMap<E,Object> map;\n\n    // Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT = new Object();\n\n    /**\n     * Constructs a new, empty set; the backing {@code HashMap} instance has\n     * default initial capacity (16) and load factor (0.75).\n     */\n    public HashSet() {\n        map = new HashMap<>();\n    }\n\n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n}\n```\n\nHashSet의 구현을 보면 내부적으로 HashMap을 이용하고 더미 객체와 add() 메서드의 파라미터를 put()메서드에 key와 value로 인자로 넣어준다.\n\n```java\n//HashMap.java\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n```\n\nHashMap의 구현을 보면 인자로 받아온 객체의 hashCode()를 이용해 키를 해쉬값으로 변환한다.\n그래서 위의 예제에서는 내용은 같지만 hashCode() 값이 다르기때문에 Set에 중복값으로 인식이 되지 않는다.\n\n```java\npublic class Equals {\n    public static void main(String[] args) {\n        Person person = new Person(0, \"hojoon\");\n        Person person2 = new Person(0, \"hojoon\");\n        System.out.println(person.equals(person2)); //true\n        System.out.println(person.hashCode()); //-1211756693\n        System.out.println(person2.hashCode()); //-1211756693\n\n        Set<Person> personSet = new HashSet<>();\n        personSet.add(person);\n        personSet.add(person2);\n        for(Person tmp:personSet){\n            System.out.println(tmp);  //p.Person@b7c60f6b\n        }\n        System.out.println(personSet.size()); //1\n    }\n}\n```\n\n다시 hashCode()를 재정의해 실행해보니 원하는 결과가 나온다.\n"},{"excerpt":"기본 자료형 데이터 타입은 데이터가 메모리에 어떻게 저장되고, 프로그램에서 어떻게 처리되어야 하는지를 명시적으로 알려주는 역할을 한다. 자바에서는 여려 형태의 타입을 미리 정의하여 제공하는데 이것을 기본 타입이라고 한다. 자바에는 8종류의 기본 타입이 제공되며, 크게 정수형, 실수형, 문자형, 논리형 타입으로 나눌 수 있다. 정수형 타입 자바의 기본 타입…","fields":{"slug":"/primitive-type/"},"frontmatter":{"date":"February 09, 2022","title":"기본 타입(primitive type)","tags":["java"]},"rawMarkdownBody":"\n## 기본 자료형\n\n데이터 타입은 데이터가 메모리에 어떻게 저장되고, 프로그램에서 어떻게 처리되어야 하는지를 명시적으로 알려주는 역할을 한다. 자바에서는 여려 형태의 타입을 미리 정의하여 제공하는데 이것을 기본 타입이라고 한다. 자바에는 8종류의 기본 타입이 제공되며, 크게 정수형, 실수형, 문자형, 논리형 타입으로 나눌 수 있다.\n\n---\n\n## 정수형 타입\n\n자바의 기본 타입 중 정수를 나타내는 타입은 다음이 있다.\n\n1. byte\n2. short\n3. int\n4. long\n\n각각의 정수형 타입에 따른 메모리의 크기 및 데이터의 표현 범위는 다음과 같다.\n\n<!--\n|제목|내용|설명|\n|------|---|---|\n|테스트1|테스트2|테스트3|\n|테스트1|테스트2|테스트3|\n|테스트1|테스트2|테스트3|\n-->\n\n| 타입  | 메모리 크기 | 표현 범위                  |\n| ----- | ----------- | -------------------------- |\n| byte  | 1 byte      | -128~127                   |\n| short | 2 byte      | $$-2^{15}$$ ~ $$2^{15}-1$$ |\n| int   | 4 byte      | $$-2^{31}$$ ~ $$2^{31}-1$$ |\n| long  | 8 byte      | $$-2^{63}$$ ~ $$2^{63}-1$$ |\n| char  | 2 byte      | $$0$$~ $$2^16-1$$          |\n\nchar는 부호(unsigned)가 없기 때문에 같은 2바이트의 메모리를 같고 있어도 표현 범위가 많다.\n\n그러면 나이 값(age)을 할당한다 했을 때 어떤 자료형을 사용해야 될까?? byte??\n\n> 과거의 16비트 컴퓨터 생각하면 메모리가 640kbyte였다. 그래서 메모리의 관리에 신경을 써야되기 때문에 어떤 자료형을 선택해야하는지가 중요했지만, 하드웨어의 발달로 인한 메모리 공간의 증가로 크게 신경쓰지 않고 자바 정수형의 기본형인 int형을 사용하면 된다고한다.\n\n### 오버플로우와 언더플로우\n\n오버플로우란 해당 타입이 표현할 수 있는 최대범위보다 큰수를 저장할 때 발생하는 현상을 가리킨다.\n반대로 언더플로우는 해당 타입이 표현할 수 있는 최소 범위보다 작은 수를 저장할 때 발생하는 현상을 가리킨다.\n\n다음 예제를 보면 결과에 어떤 영향을 주는지 알 수 있다.\n\n```java\npublic class Primitive {\n    public static void main(String[] args) {\n        byte num1 = 127;\n        byte num2 = -128;\n\n        num1++;\n        num2--;\n\n        System.out.println(num1);\n        System.out.println(num2);\n    }\n}\n```\n\n실행 결과\n\n![](result.png)\n\nbyte타입의 표현 범위는 -128~127 이다. 위의 예제는 num1에 1을 더하고 num2에 1을 빼려고 한다. 그 결과 오버플로우와 언더플로우가 발생해 예상하지 못한 결과가 나오게된다.\n\n저런 결과가 나오는 이유는 뭘까??\n\nnum1와 num2를 비트로 표현하면 다음과 같이 표현할 수 있다.\n\n| num1  | 8   | 7       | 6       | 5       | 4       | 3       | 2       | 1       |\n| ----- | --- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |\n| 2진수 |     | $$2^6$$ | $$2^5$$ | $$2^4$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ |\n| 값    | 0   | 1       | 1       | 1       | 1       | 1       | 1       | 1       |\n\n| num2  | 8   | 7       | 6       | 5       | 4       | 3       | 2       | 1       |\n| ----- | --- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |\n| 2진수 |     | $$2^6$$ | $$2^5$$ | $$2^4$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ |\n| 값    | 1   | 0       | 0       | 0       | 0       | 0       | 0       | 0       |\n\nnum1와 num2에 각각 1을 더하고 빼면 다음과 같은 결과가 된다.\n\n| num1  | 8   | 7       | 6       | 5       | 4       | 3       | 2       | 1       |\n| ----- | --- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |\n| 2진수 |     | $$2^6$$ | $$2^5$$ | $$2^4$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ |\n| 값    | 1   | 0       | 0       | 0       | 0       | 0       | 0       | 0       |\n\n| num2  | 8   | 7       | 6       | 5       | 4       | 3       | 2       | 1       |\n| ----- | --- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |\n| 2진수 |     | $$2^6$$ | $$2^5$$ | $$2^4$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ |\n| 값    | 0   | 1       | 1       | 1       | 1       | 1       | 1       | 1       |\n\n이렇게 오버플로우와 언더플로우가 어떻게 발생하는지 알아봤다.\n\n## 실수형 타입\n\n실수란 소수부나 지수부가 있는 수를 가리키며, 정수보다 훨씬 더 넓은 표현 범위를 가진다.\n\n| 실수형 타입 | 할당되는 메모리 크기 | 지수의 길이 | 가수의 길이 |            유효 자릿수             |\n| :---------: | :------------------: | :---------: | :---------: | :--------------------------------: |\n|    float    |        4byte         |    8bit     |    23bit    | 소수 부분 6자리까지 오차없이 표현  |\n|   double    |        8byte         |    11bit    |    52bit    | 소수 부분 15자리까지 오차없이 표현 |\n\n과거에는 float 형을 많이 사용했지만, 하드웨어의 발달로 인한 메로리 공간의 증가로 현재는 double형을 가장 많이 사용한다.\n이 두 가지 타입은 간단한 계산에서는 사용해도 무방하지만, 돈 계산과 같이 정확하고,중요한 부분에서는 사용하면 안되고 BigDecimal 클래스를 사용해야 한다.\n\nfloat과 double은 다음과 같이 정의되어 있다.\n\n> float: single-precision 32-bit IEEE 754 floating point\n>\n> double: double-precision 64-bit IEEE 754 floating point\n\nfloat은 \"단정도 32비트 IEEE 754 부동 소수점\", double은 \"배정도 64비트 IEEE 754 부동 소수점\" 이라고 한다.\n\n그림으로는 아래와 같이 나타낼 수 있다.\n\n![](float.png)\n\n![](double.png)\n\n부동소수점 방익은 숫자를 0과 1을 이용해서(근사해서) 표현하는 방식 중 하나이다.\nIEEE 754 부동 소수점 표현에서 숫자는 **부호부**, **지수부**, **가수부**의 세부분으로 구성된다.\n\n### 부동소수점 변환 예시\n\n숫자 0.1을 부동소수점 방식으로 표현해 보겠다.\n\n### 부호부\n\n부호가 음수이므로 가장 앞자리는 0이 된다.\n\n| 부호 | 지수 |     |     |     |     |     |     |     | 가수 |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |\n| ---- | ---- | --- | --- | --- | --- | --- | --- | --- | ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 0    | -    | -   | -   | -   | -   | -   | -   | -   | -    | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   | -   |\n\n### 가수부\n\n숫자의 절대값을 2진수로 표현한다.\n0.1은 2진수로 표현하면 다음과 같다.\n\n$$\n0.0001100110011001100110011001100110011001100110011001101...._{(2)}\n$$\n\n2 진수의 소수점을 왼쪽으로 이동시켜서 소수점 왼쪽에 1만 남도록 한다.\n\n$$\n1.100110011001100110011001100110011001100110011001101...._{(2)} *2^{-4}\n$$\n\n이 방식을 정규화된 표현 방식이라고 한다.\n\n그리고 소수점의 오른쪽 부븐을 가수부 23비트의 앞에서 부터 채워준다.\n\n| 부호 | 지수 |     |     |     |     |     |     |     | 가수 |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |\n| ---- | ---- | --- | --- | --- | --- | --- | --- | --- | ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 0    | -    | -   | -   | -   | -   | -   | -   | -   | 1    | 0   | 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   | 0   |\n\n자리가 남는다면 0으로 채워주고 지금은 비트를 초과해 중간에 잘리게 되었다.\n\n### 지수부\n\n지수는 -4이다.\n지수에 bias인 127을 더해준다.(bias는 $$2^{k-1}$$ 로 주어지는데 k는 지수부의 비트수 이다.)\n-4에 bias를 더한 123을 2진수로 변환하면 $$01111011_{(2)}$$이 된다. 그리고 변환한 값을 8비트 지수부에 채워주면 다음과 같은 결과가 나온다.\n\n| 부호 | 지수 |     |     |     |     |     |     |     | 가수 |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |\n| ---- | ---- | --- | --- | --- | --- | --- | --- | --- | ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 0    | 0    | 1   | 1   | 1   | 1   | 0   | 1   | 1   | 1    | 0   | 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   | 0   |\n\n### 부동 소수점 방식의 오차\n\n부동 소수점 방식을 사용하면 고정 소수점 방식보다 훨씬 더 많은 범위까지 표현할 수 있다.\n하지만 위의 변환을 보면 한정된 범위의 가수부 비트에 값을 넣은 것을 볼 수 있다. 그래서 부동 소수점 방식에 의한 실수 표현은 근사치를 표현할 뿐이지 오차가 존재한다.\n\n```java\npublic class Primitive {\n    public static void main(String[] args) {\n        double num = 0.1;\n\n        for(int i = 0; i < 1000; i++) {\n            num += 0.1;\n        }\n        System.out.print(num);\n    }\n}\n```\n\n실행 결과\n\n![](result2.png)\n\n위의 예제의 결과화면을 보면 오차가 발생한것을 확인할 수 있다.\n\n## 논리형 타입\n\n논리형은 참(true)이나 거짓(false) 중 한 가지 값만을 가질 수 있는 불리언 타입을 의미한다.\n\n| 논리형 타입 | 메모리 크기 | 표현범위        |\n| ----------- | ----------- | --------------- |\n| boolean     | 1byte       | true 또는 false |\n\nboolean형의 기본값은 false이며, 1byte의 크기를 가진다.\n\n## 형 변환(casting)\n\n형 변환은 서로 다른 타입 사이에 변환하는 작업을 말한다.\n기본 자료형에서는 논리형 타입을 제외하고 형 변환이 가능하다.\n\n```java\nbyte byteValue = 127;\nshort shortValue = byteValue;\n```\n\n다음과 같이 범위가 작은 타입에서 큰 타입으로의 변환은 별도의 명시 없이도 형변환이 이루어진다.\n\n```java\nbyte byteValue = 127;\nshort shortValue = byteValue;\nbyteValue = (byte)shortValue;\n```\n\n하지만 범위가 큰 타입에서 작은 타입으로 다운캐스팅 할때는 변환되는 타입을 명시해 줘야된다.\n\n```java\npublic static void main(String[] args) {\n        byte byteValue = 127;\n        short shortValue = byteValue;\n\n        shortValue++;\n        System.out.println(shortValue);\n        byteValue = (byte)shortValue;\n        System.out.println(byteValue);\n    }\n```\n\nbyteValue를 short로 형변환을 해서 ++연산자로 증가 시키고 다시 byte로 변환을 하면 어떤 결과가 나올까?\n\n실행 결과\n\n![](result3.png)\n\nshort의 128를 byte로 변환시키면 다음과 같은 상태가 된다.\n\n| byteValue | 8   | 7       | 6       | 5       | 4       | 3       | 2       | 1       |\n| --------- | --- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |\n| 2진수     |     | $$2^6$$ | $$2^5$$ | $$2^4$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ |\n| 값        | 1   | 0       | 0       | 0       | 0       | 0       | 0       | 0       |\n\n맨 앞의 비트는 부호를 나타내는 비트이므로 무시가 되서 -128이라는 결과가 나오게 된다.\n이와 같이 범위가 작은 타입으로 형 변환을 하게되면, 예상치 못한 결과가 나올 수 있으므로 주의해야된다.\n"},{"excerpt":"공부를 하다보니 HashCode, HashSet, HashMap 등 해시란 용어가 자주 언급이되서 더 자세히 알아보기 위해 글을 작성했다. 해싱이란? 해싱(Hashing)은 키값을 비교하여 찾는 검색 방법이 아니라 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 바로 찾아가는 계산 검색 방식이다.\n키값을 원소 위치로 변환하는 함수를 해시 함수(Hash…","fields":{"slug":"/hashing/"},"frontmatter":{"date":"February 04, 2022","title":"해싱이란?","tags":["자료구조"]},"rawMarkdownBody":"\n공부를 하다보니 HashCode, HashSet, HashMap 등 해시란 용어가 자주 언급이되서 더 자세히 알아보기 위해 글을 작성했다.\n\n# 해싱이란?\n\n해싱(Hashing)은 키값을 비교하여 찾는 검색 방법이 아니라 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 바로 찾아가는 계산 검색 방식이다.\n키값을 원소 위치로 변환하는 함수를 **해시 함수**(Hash Function)라고 하고, 해시 함수에 의해 계산된 주소 위치에 항목을 저장한 표를 **해시 테이블**(Hash Table)이라고 한다.\n매핑 전 데이터의 값을 **키**, 해시함수를 이용해 매핑 후의 데이터 값을 **해시값**이라고 한다.\n전산화되어 있는 도서 검색 시스템에서 제목을 입력하여 책의 위치를 찾는 것을 해싱의 예라고 할 수 있다.\n\n## 해시 테이블\n\n<p align=\"center\">\n    <img src=\"hashtable.png\">\n</p>\n\n해시 테이블은 **키**(key),**해시함수**(Hash Fuction),**해시**(Hash),**값**(Value),**저장소**(Bucket,Slot)로 이루어져 있다. 해시함수를 사용해 키를 해시값으로 매핑하고, 이 해시값은 Index 혹은 주소로 데이터의 값을 키와 함께 저장하는 구조를 해시테이블이라고 한다. 이 때 데이터가 저장되는 곳을 버킷 또는 슬롯이라고 한다. 해시테이블의 기본 연산은 삽입, 삭제, 탐색이다.\n\n## 동거자(Synonym)\n\n모든 키값이 고르게 사용되는 건 아니다. 많이 사용되는 키값이 있을 수 있고 거의 사용되지 않는 키값이 있을 수 있다. 따라서 키값의 수만큼 버킷을 많이 만들면 메모리 공간이 낭비되기 때문에 해시테이블에서는 버킷 수를 줄이고 버킷안에 슬롯을 만들어 해시 함수로 만든 해시값이 같은 키값들을 같은 버킷에 저장한다. 이 처럼 서로 다른 키값을 가지지만 해시 함수에 의해 같은 버킷에 저장된 키값을 동거자라고 한다.\n\n## Load Factor\n\nm(해시테이블의 크기 = 버킷 개수 \\* 슬롯 개수), n(실제 사용 중인 키값의 개수)이라고 했을 때, n/m을 load factor하고 한다. 해시테이블의 크기에 몇개의 키가 매핑되는가를 나타내는 지표이다. load factor는 1 이하이며, 1보다 큰 경우 충돌이 발생한다.\n\n## 충돌(Collision)\n\n키값이 서로 다름에도 불구하고 해시 함수에 의해 만들어진 해시 값은 같을 수가 있다. 이와같은 경우를 충돌이라고 한다. 너무 많은 해시 충돌은 해시 테이블의 성능을 떨어뜨린다. 충돌시 해결 방법을 알아보자\n\n- 해시함수의 입력값은 무한하지만 출력값의 가짓수는 유한하므로 해시충돌은 반드시 발생한다.\n- 클러스터링(Clustering): 연속된 레코드에 데이터가 몰리는 현상\n- 오버플로우(Overflow): 해시 충돌이 버킷에 할당된 슬롯 수보다 많이 발생하면 더이상 버킷에 값을 넣을 수 없는 현상\n\n## 충돌 해결 방법\n\n### 1. 체이닝\n\n연결리스트\n\n### 2. 선형 개방 주소법\n"},{"excerpt":"Java Virtaul Machine JVM JVM Java Virtual Machine 자바 가상 머신을 약자로 줄여놓은 용어이다. 가상머신이란 프로그램을 실행시키기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것이라고 할 수 있다. JVM은 자바 어플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행시키는 역할을 한다. JVM의 특징…","fields":{"slug":"/jvm/"},"frontmatter":{"date":"January 29, 2022","title":"Java Virtaul Machine","tags":["java"]},"rawMarkdownBody":"\n# Java Virtaul Machine\n\n## JVM\n\nJVM Java Virtual Machine 자바 가상 머신을 약자로 줄여놓은 용어이다. 가상머신이란 프로그램을 실행시키기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것이라고 할 수 있다. JVM은 자바 어플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행시키는 역할을 한다.\n\nJVM의 특징\n\n- **스택 기반의 가상 머신**: 대표적인 컴퓨터 아키텍처인 인텔이나 ARM 아키텍처 같은 하드웨어는 레지스터 기반으로 동작하지만 JVM은 스택 기반으로 동작한다.\n- **심볼릭 레퍼런스**: 기본 자료형을 제외한 모든 타입을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심복릭 레퍼런스를 통해 참조한다.\n- **가비지 컬렉션(Garbage Collection)**: 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.\n- **기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장**: C/C++ 등의 언어는 플랫폼에 따라 int형의 크기가 변한다. JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.\n- **네트워크 바이트 오더**: 자바 클래스 파일은 네트워크 바이트 오더를 사용한다. 인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크 바이트 오더를 사용한다. 네트워크 바이트 오더는 빅 엔디안이다.\n\n### 스택 기반과 레지스터 기반의 차이\n\n가장 큰 차이는 피연산자를 저장하고 다시 가져오는 메카니즘이 다르다.\n\n### Stack 기반 가상 머신\n\n![](stack.png)\n\n- Java VM, Net Clr\n- 대다수의 가상머신이 스택기반\n- 피연산자와 연산 후 결과를 스택에 저장한다.\n- 위의 경우 스택 구조이기 때문에 Push, Pop이 필요하며 4단계의 명령이 필요하다.\n- 장점: 다음 피연산자의 메모리 위치를 기억할 필요가 없다. 스택에서 pop만 하면 피연산자가 나오기 때문에 메모리를 기억할 필요가 없다.\n\n### Register 기반 가상 머신\n\n![](register.png)\n\n- Lua VM, Dalvik VM\n- 피연산자가 CPU의 레지스터에 저장된다.\n- Push, Pop 연산자가 없다.\n- 명령어가 피연산자의 위치인 레지스터의 주소를 기억해야 한다.\n- 장점\n\n  1. Pop, Push 과정이 없기 때문에 같은 덧셈이라도 하나의 명령으로 충분하다.\n  2. 스택기반에서는 할 수 없는 명령어 최적화를 적용할 수 있다. 예) 어떤 연산이 나중에 또 필요할 때, 레지스터에 저장하여 다시 계산하지 않고도 결과를 활용할 수 있다.\n\n- 단점\n  1. 스택기반보다 명령어의 길이가 길다. 피연산자의 주소를 명시해줘야 하기 때문에.\n\n### 심볼릭 레퍼런스\n\n심볼릭 레퍼런스란 참고하는 클래스의 특정 메모리 주소를 참조 관계로 구성한 것이 아니라, 참조하는 대상의 이름만을 지칭한 것이다.\n\n### JVM 구조\n\n<p align=\"center\">\n    <img src=\"jvm.png.png\">\n</p>\n\n작성한 코드는 다음과 같은 과정을 통해 수행된다.\n클래스 로더가 컴파일된 자바 바이트코드를 런타임 데이터 영역에 로드하고, 실행 엔진이 자바 바이트 코드를 실행한다.\n\n### Class Loader\n\n자바는 컴파일 타임이 아니라 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다. 이 동적로드를 담당하는 부분이 클래스 로더이다.\n클래스 로더의 특징으로는 다음이 있다.\n\n- 계층 구조: 클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성된다. 최상위는 부트스트랩 클래스 로더이다.\n- 위임 모델: 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 동작한다. 클래스를 로드할 때 상위 클래스 로더를 확인하여 해당 클래스 로더에 있다면 클래스를 사용하고, 없다면 로드를 요청받은 클래스로더가 클래스를 로드한다.\n- 가시성 제한: 하위 클래스로더는 상위 클래스로더의 클래스를 찾을 수 있지만, 반대 경우는 찾을 수 없다.\n- 언로드 불가: 클래스로더는 클래스를 로드할 수는 있지만 언로드할 수는 없다. 대신, 현재 클래스 로더를 삭제하고 아예 새로운 클래스로더를 생성하는 방법을 사용할 수 있다.\n\n각 클래스로더는 클래스들을 보관하는 네임스페이스를 갖는다. 클래스를 로드할 때 이미 로드된 클래스인지 확인하기 위해서 네임스페이스에 보관된 FQCN(Fully Qualified Class Name)을 기준으로 클래스를 찾는다.\n\n<p align=\"center\">\n    <img src=\"link.png\">\n</p>\n\n클래스 로더가 아직 로드되지 않은 클래스를 찾으면, 다음과 같은 과정을 통해 클래스를 로드하고 링크하고 초기화한다.\n\n- 로드: 클래스를 파일에서 가져와서 JVM의 메모리에 로드한다.\n- 검증: 읽어들인 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사한다.\n- 준비: 클래스가 필요로 하는 메모리를 할당하고, 클래스에서 정의된 필드, 메서드, 인퍼페이스들을 나타내는 데이터 구조를 준비한다.\n- 분석: 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.\n- 초기화: 클래스 변수들을 적절한 값으로 초기화한다. static initializer들을 수행하고, static 필드들을 설정된 값으로 초기화한다.\n\n### Runtime Data Area\n\n![](runtime.png)\n\n런타임 데이터 영역은 JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 런타임 데이터 영역은 6개의 영역으로 나눌 수 있다.\n\n- PC Register: 스레드가 시작될 때 생성되며 스레드마다 하나씩 존재한다. 스레드가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행중인 JVM 명령의 주소를 갖는다.\n- JVM Stack: 스레드의 수행 정보를 스택프레임을 통해서 저장한다. 메소드가 호출되면 메소드와 정보는 스택에 쌓이고 종료될 때 스택포인트에서 제거된다. 스택 프레임은 지역 변수 배열, 피연산자 스택, 현재 실행중인 메서드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스를 갖는다.\n- Native method Stack: 자바 외의 언어로 작성된 네이티브 코드를 위한 스택이다.\n- Method Area: 메소드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 정보, static 변수,메서드의 바이트코드 등을 보관한다.\n- Runtime Constant Pool: 클래스 파일 모맷에서 상수 풀 테이블에 해당하는 영역이다. 메스드 영역에 포함되있지만 JVM동작에서 가장 핵심적인 역할을 수행하는 곳이다. 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아 참조한다.\n- Heap: 객체를 저장하는 공간으로 가비지 컬렉션의 대상이다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다.\n\n### Execution Engine\n\n런타임 데이터 영역에 배치된 바이트코드는 실행 엔진에 의해 실행된다. 실행 엔진은 명령어 단위로 읽어서 실행한다. 실행 엔진은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경하며, 그 방식은 두가지가 있다.\n\n1. 인터프리터: 명령어를 하나씩 읽어서 해석하고 실행한다. 바이트코드 하나하나의 해석은 빠른 대신 인터프리팅 결과의 실행은 느리다는 단점을 가지고 있다. 흔히 얘기하는 인터프리터 언어의 단점을 그대로 가지는 것이다.\n2. JIL(Just-In-Time): 인터프리터의 단점을 보완하기 위해 도입된 것이 JIT 컴파일러이다. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고 실행하는 방식이다.\n"}]}},"pageContext":{}},"staticQueryHashes":[]}