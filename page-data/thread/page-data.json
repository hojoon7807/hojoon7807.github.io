{"componentChunkName":"component---src-templates-post-jsx","path":"/thread/","result":{"data":{"site":{"siteMetadata":{"title":"Dev.HJ"}},"markdownRemark":{"id":"0e33327d-d671-5b12-aa17-919f5b7107bd","excerpt":"쓰레드란?? 이전 포스팅에서 프로세스에 대해 알아보았다. 프로세스는 간단히 설명하면 프로그램이 메모리에 올라가 CPU를 할당받은 실행중인 프로그램이라고 말할 수 있다. 그리고 프로그램을 수행하는데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있으며 이 자원들을 이용해 실제로 작업을 수행하는 실행되는 흐름의 단위를 쓰레드라고 한다. 쓰레드는 …","html":"<h2>쓰레드란??</h2>\n<p>이전 포스팅에서 프로세스에 대해 알아보았다.<br>\n프로세스는 간단히 설명하면 프로그램이 메모리에 올라가 CPU를 할당받은 실행중인 프로그램이라고 말할 수 있다. 그리고 프로그램을 수행하는데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있으며 이 자원들을 이용해 실제로 작업을 수행하는 실행되는 흐름의 단위를 <strong>쓰레드</strong>라고 한다.</p>\n<p>쓰레드는 lightweight-process라고도 하며 한 번에 하나의 작업만 수행하는 것을 싱글 쓰레드, 하나의 프로세스가 동시에 여러 작업을 수행하는 것을 멀티 쓰레드라고 한다.</p>\n<p align='center'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/935332f057eee1cc7e9f0bd4719c4fae/fc0cd/thre.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 60.58823529411765%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAByklEQVQoz21TaVeDMBDs//9h2hbKVcQeautHW3pACCThGHeDVPCZ9/YNJJvZ2Ukyq+saQgiKAkVRjFBASomu69C27WNODCgGFGiaBjw4d5amKXw/QPK6gef5CKM1oihGHL9QJKhNjaqqEIYRzdPaOn4g5zDe7/dfwq+vE56enrF0XLjuCgFtdFceVhS+H4I7YMLl0qFw8TxfwHF65LnFwpkSpunFVkySV2y2OxwOR2wJd/s3wv2D0HU9W2i+WNpOGB0rwiPC7JdQa203sQ+MxhiK/l8pZf1jQraBC/tBaNsMguhhz4SQCcajG30zKROWZWk9XJNnrDJ+SUhl0Pv610NWcblcUNBpVbpGZjpesQmseFC42+1xPH5aaz4JN5st3t/e8fFxQJbl05Y5WKkyDUQ9JbQqKYqyQqYMSrpKd0W+kuqbrCBpTlFB3v9/y9205YFQ1S0EXbea8jNGmstMC8kisgzX283m2pZZCbOPg1vltYG0rBRM00JzfttZRZXuD9BQh8OY8WaWfzqdwJf8fD4jJU/zXJCydlSAlOS5Xb9er73v9Gq4MMeQNxta4ydUFJIOp7Cofqp2Iw+U0vY5SllCkgitzciqPu8bgXCOuWSOoSkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='thre' title='thre' src='/static/935332f057eee1cc7e9f0bd4719c4fae/ca1dc/thre.png' srcset='/static/935332f057eee1cc7e9f0bd4719c4fae/e7570/thre.png 170w,\n/static/935332f057eee1cc7e9f0bd4719c4fae/f46e7/thre.png 340w,\n/static/935332f057eee1cc7e9f0bd4719c4fae/ca1dc/thre.png 680w,\n/static/935332f057eee1cc7e9f0bd4719c4fae/02d09/thre.png 1020w,\n/static/935332f057eee1cc7e9f0bd4719c4fae/9d567/thre.png 1360w,\n/static/935332f057eee1cc7e9f0bd4719c4fae/fc0cd/thre.png 1624w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>여러개의 프로세스가 있을때 각각의 프로세스는 독립적인 메모리 영역을 가진 반면,<br>\n쓰레드는 각각 Stack, PC(program counter), registers 영역을 가지고 code, data, heap 영역을 공유한다.</p>\n<h2>멀티쓰레드</h2>\n<p>그럼 기존의 멀티 프로세스 방식 대신에 멀티쓰레드를 사용할까? 각각에 대해서 간단히 알아보자.</p>\n<h3>멀티 프로세스</h3>\n<p>각각의 프로세스들은 독립된 메모리 영역을 가진다. 프로세스간 통신하기 위해서는 IPC를 사용해야 한다.<br>\n여러개의 프로세스 중에서 하나가 죽어도 다른 프로세스에 영향을 미치지 않는다.</p>\n<h3>멀티 쓰레드</h3>\n<p>하나의 프로세스가 다수개의 작업을 각각의 쓰레드를 통하여 동시에 실행할 수 있고, 독립적인 프로세스처럼 작업을 수행한다.<br>\n대표적인 예시로 웹서버가 있다.</p>\n<p align='center'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/01329964f29200eaf2f5377a1d7b3b81/af7a3/web.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 42.35294117647059%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABE0lEQVQoz31SW26DMBD0/W/Sj6oH6FcvUPWnLaSEBqk8S1II8QtsT20nJJDXSgOSZ3eYHUOMMXDQB5zXPc7VyJkDT64oQAgBxhiU1jNKco40y5ClKfK8gD7jnShx6kkn8V53iLcSXEq0TYOyqiAFR0klPtc7LBqB37bDMooQBCG+4xh/lCOw3Ee9Q8H6vUPn4qVkeIhqPBccVEj7Kb13pxVei9Zyazz9UORW3J1xu4FRA9Itw2O88fzbRowrGy/gYZunq/uM+h49o1DWre+5iEgf4SaIe8wwCVgp5QMf7HsYhmP4J8xn3QExF00nQWnzTFYJwsUXwiBAXpSj8Zsz5NqvMG2o7OWskgRLewmUsiN/q/4B1zdwCxzIby8AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='web' title='web' src='/static/01329964f29200eaf2f5377a1d7b3b81/ca1dc/web.png' srcset='/static/01329964f29200eaf2f5377a1d7b3b81/e7570/web.png 170w,\n/static/01329964f29200eaf2f5377a1d7b3b81/f46e7/web.png 340w,\n/static/01329964f29200eaf2f5377a1d7b3b81/ca1dc/web.png 680w,\n/static/01329964f29200eaf2f5377a1d7b3b81/02d09/web.png 1020w,\n/static/01329964f29200eaf2f5377a1d7b3b81/9d567/web.png 1360w,\n/static/01329964f29200eaf2f5377a1d7b3b81/af7a3/web.png 1706w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>클라이언트에서 요청이 오면 서버에서는 쓰레드를 생성해 요청 작업을 수행해서 이 후에 추가되는 요청도 계속해서 받을 수 있다.</p>\n<p>멀티 쓰레드의 장점을 정리하면 다음과 같다.</p>\n<ul>\n<li>쓰레드는 프로세스의 자원을 공유해서 사용하기 때문에 프로세스와 달리 쓰레드간에 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어든다.</li>\n<li>멀티 프로세스로 실행되는 작업을 멀티 쓰레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능하다.</li>\n<li>프로세스의 문맥 교환에 비해 쓰레드의 문맥 교환은 오버헤드가 더 작다.</li>\n<li>확장성이 용이하다.</li>\n</ul>\n<p>단점도 존재한다. 위의 내용대로 쓰레드들은 프로세스의 자원을 공유해서 같이 사용하기 때문에 동기화 작업이 이루어지지 않는다면 데이터의 일관성이 문제가 생길 것이다. 또 하나의 쓰레드에 오류가 생기면 같은 프로세스 내의 다른 쓰레드들도 모두 강제 종료가 된다.</p>\n<h2>Multicore Programming</h2>\n<p>멀티코어 시스템을 구현할 때는 동시성(Concurrency)와 병렬성(Parallelism)을 알아야 한다.<br>\n동시성은 싱글 코어 시스템에서 사용되는 방식으로, 프로세서가 여러개의 쓰레드를 번갈아가면서 수행함으로 동시에 실행되는 것처럼 보이게 하는 방식이다.</p>\n<p align='center'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/73a62197baa5a4924d3fb637377ee573/e9562/s.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 15.88235294117647%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAuElEQVQI112OTWvCQBRF8///TEHpulgKWQbBGkEmM5lJkKSJRsznTMxxEHHRtzpwuee+wNqJqqppr1fCsuMza0mFINR/rEyLUJpI5qzKmVgaYpXxYToiXSCEZJ33hKbmpA1dPxA4a7k0Dd3txuHS82POKC+M0hObtELIlL2XrOOM32PCURm+dM1O5SSJ5NvLtllJVRSM40TA/3MT1o/M/vPFvthZ2ubMOAxPXuz4zJ3n+zSwzO5dfwDOkuCgF53sdgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='s' title='s' src='/static/73a62197baa5a4924d3fb637377ee573/ca1dc/s.png' srcset='/static/73a62197baa5a4924d3fb637377ee573/e7570/s.png 170w,\n/static/73a62197baa5a4924d3fb637377ee573/f46e7/s.png 340w,\n/static/73a62197baa5a4924d3fb637377ee573/ca1dc/s.png 680w,\n/static/73a62197baa5a4924d3fb637377ee573/02d09/s.png 1020w,\n/static/73a62197baa5a4924d3fb637377ee573/9d567/s.png 1360w,\n/static/73a62197baa5a4924d3fb637377ee573/e9562/s.png 1438w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>시분할을 통해 쓰레드들을 수행하는 모습을 볼 수 있다.</p>\n<p>병렬성은 멀티 코어 시스템에서 사용되는 방식으로, 여러개의 코어가 각 쓰레드를 동시에 수행하는 방식이다.</p>\n<p align='center'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/8ca7ad3364f75e1f894a8922f0ab975a/d75ff/m.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 38.82352941176471%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABbklEQVQoz21R21LCMBDl/z9CHqgIPPAbjoMzWhiw9EIvtFJok16RQgvHTbCKjpk5s2fPbk6ySQc3q2nOaC4X1E2D+kz8fOWtJvKG9FutxYVysTpnathFEQ5FgcewwJ0WY+gWUJYRFIPhwc7QW8boW4mE4AM7haIzmY+CI8ZujrI6/Rj6QYB9nuEp+kBX52SSo79K0V2EGK73UEyOe8oHTo7uPMSItJ7B0ae+gX/A2CtQHr8Mb0fO8gJxkiLmCSKWgKUZdjGTMWJc1hhBcJ7mV416BRoaWxoKYpomNpsQQfAO9UWFoZtYzN8wm81hGhZpUxl1bYmpOodlmFBfp9A0Ha7rYWXZqKrqaigesyxLnE4nbLc7uXG1cuB5a+hkvF77dCCZqjO4jged6kKzyMS2Hckdx8Xxv5GFeXU4gDMGzjmSJJHYhiGeJxP4foAsy8CoLnQWx7JP7Pv+5TZpBfFJdV3/Qvs+IopJ/tbbywh8Ah8+WEDMtThVAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='m' title='m' src='/static/8ca7ad3364f75e1f894a8922f0ab975a/ca1dc/m.png' srcset='/static/8ca7ad3364f75e1f894a8922f0ab975a/e7570/m.png 170w,\n/static/8ca7ad3364f75e1f894a8922f0ab975a/f46e7/m.png 340w,\n/static/8ca7ad3364f75e1f894a8922f0ab975a/ca1dc/m.png 680w,\n/static/8ca7ad3364f75e1f894a8922f0ab975a/d75ff/m.png 994w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>parallelism은 data parallelism과 task parallelism 두 가지로 구분할 수 있는데 다음과 같이 말할 수 있다.</p>\n<ul>\n<li>Data: 작업량의 분배 ex) 1~100을 더해야 하는 경우 cpu1는 1~50까지의 데이터를, cpu2는 51~100까지의 데이터를 계산한 후에 합친다.</li>\n<li>Task: 하는 업무의 분배 ex) 1~50은 더하고, 51~100은 곱해 합산한다. cpu1은 더하는 업무를, cpu2는 곱하는 업무를 수행한 후 합친다.</li>\n</ul>\n<h2>User Threads, Kernel Threads</h2>\n<ul>\n<li>User Threads: 유저 쓰레드는 커널의 지원없이 관리되는 쓰레드로 POSIX Pthreads, Win32 threads, Java threads 같이 쓰레드 라이브러리를 통해 구현되고 유저가 관리하는 쓰레드이다. 커널 쓰레드에 비해 안정성은 떨어지지만 성능이 저하되지 않는다.</li>\n<li>Kernel Threads: 커널이 쓰레드 기능은 API형태로 제공하며, 생성된 쓰레드에 대해서 커널이 직접 관리한다. 커널 쓰레드는 안정적이지만 유저 모드에서 커널 모드로 전환이 빈번하게 일어나기 때문에 성능이 저하된다.</li>\n</ul>\n<h2>Multithreading Models</h2>\n<p>Multithreading Models란 유저 쓰레드와 커널 쓰레드의 관계를 설계하는 방법이다. 다음과 같은 방법이 있다.</p>\n<h3>Many-to-one model</h3>\n<p align='center'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/163e878570cd507995c3257a8dde1029/6f18b/mo.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 75.88235294117648%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACaklEQVQ4y6VT247aMBDl//9m1adlgYoVqkQJoXTJAgES20mcC8tlIYSuBJzOOEkFz7U0GscZH8+cM9O4XC44nU7Gisqz5cccx+MR2+3W+M/9HgfyRVHcxRe4Xq+43W7GeDU42PN8CCHh+xKS/GrlodVqo9t9RbvTwUurg29PT7DsXwiCkOJEFS8McL0YtJHnOaJIQ8cJbJki1AnWSYwR7Vdhgk2awlEJZkGKjySBF5ZxGe2jKDZVKaWgwqjMkAH5VQbteSlElOAj1vjhEQgBrXWEsUww9MvzJQH2VglSrc2d7XaD6XSKubtATuBVhhFlmGLka3hUdhbHeCOQpaIL6zUcoeEGMVI6n3sSYxGbDDVVwxxrAk/o+1ScSw6ZCykVfM/DfDaH47zDmTiwrSFG9gjWwKLvCd4dymTuQvi+iRd0j0W6XxWgb8TgIKUCQzjvF4sVxuPf9BCJxgB0zv9ltedEzufzI2AtSkyisDBax8YnVJ7SLEBmyjHnlXFsbWuiZL/bY7PZoCDwf6JwIAMbxfkSmSQVe16G6A6sjqmTkEIQ7z5Vs8T+cCgBQ5I8rrJjH6iQHqHSgwgDV0BRifwol1rH1bFbymw6m5HKLj4PxxJQiPIS88IvWz8tNJtNtNrf8drtovXSxvNzE03yHCfvjDX48/VljKeuUY8eA5/ycqSYaDYeLeblTO3Aat6PnRm9gkfv9igK/nPVc1xb40SZ9ft9DG0bLvHgLlyabQ9BGOCNeo+55MZnk1ISb9r8nzgOdrvdA6jJkEteEMjAsswFJptHiLkJwtD0aJZlpj14ItgzuKKH6qauwXj9BVX1XFYh2bwnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mo' title='mo' src='/static/163e878570cd507995c3257a8dde1029/ca1dc/mo.png' srcset='/static/163e878570cd507995c3257a8dde1029/e7570/mo.png 170w,\n/static/163e878570cd507995c3257a8dde1029/f46e7/mo.png 340w,\n/static/163e878570cd507995c3257a8dde1029/ca1dc/mo.png 680w,\n/static/163e878570cd507995c3257a8dde1029/6f18b/mo.png 886w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>하나의 커널 스레드에 여러 개의 유저 스레드를 연결하는 모델이다. 한 번에 하나의 유저 스레드만 커널에 접근할 수 있기 때문에 멀티코어 시스템에서 병렬적인 수행을 할 수가 없다. 요즘에는 잘 사용되지 않는 방식이다.</p>\n<h3>One-to-one model</h3>\n<p align='center'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/43d47ebc5efba1607404c1766b1a32da/6f18b/oo.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 75.88235294117648%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACY0lEQVQ4y61T23LaQAzl/3+qDwWCCYXQcLWNL7ter29AaMhDSMLp0TpQMtO+VTMay1rtkXSk7YDy9vaG0+n0RT8+PnA+n6/fi/2vuIt2xJllBnmew1JzpxbThwcMPQ8Dbwhv4MG7G2A0GsPawsVZxmitcTgccBUBfH19hVLaBSyVRZpZlLRHcx/j2RLRZoPpfIn+dIHQD6BMGyfxcm+/3+Pw9ISqqh3mFbC0Fr1NgUBbNDbHT13jMauxKwts8gqDtMG2LB1gl3FaKuS93W6HJI6xXvs4kborYMGAYczLBKwJOE0KzFKLiu1JEi8qnC2AHuMyxgtVZVHAD0KsgwDNdnvTMrkJYwWlMxTOTsmRoZ+t8Sv/4m9t1dqfLbf0nf+0HBA9imKsFgsE5CmOk6st/pDnq/nC+cUnZ2JLm1tWJXKZ9pehrJKMQzHMbrGmnejcUZFmuTsTv+K52PYvFX4BlKH0o9LxJRxOEosHak3efNUOrMqN47DHOM1vbsiv7yNOWHkYom6aT0DyJoADEh8ScMvJzrIGC9NgX1WIOOV7tcW+rjndgollKIUbilQdbiKsCbzb7VvANFXucKMMjLROjr5179AfDNHr9dHt3eF738P3bg9+GCHmrhpj3L2aCQ27MKz2+fkZHXl2MklRyVZy19IkxWq5pK6YObgOYr5YusQVV6UoSsf78fiCW+ngP8jte+68HI/w+GZ/jMfwyUNIcieTCXSWcS3WrChz7ztV3FGq1gqPsxksK7zdv+sevr+/cw993I9G5ITLy3YETB69gFUcRNPUBCjcWbvoGr/I1+26XOQ3IMNbeSPxhUcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='oo' title='oo' src='/static/43d47ebc5efba1607404c1766b1a32da/ca1dc/oo.png' srcset='/static/43d47ebc5efba1607404c1766b1a32da/e7570/oo.png 170w,\n/static/43d47ebc5efba1607404c1766b1a32da/f46e7/oo.png 340w,\n/static/43d47ebc5efba1607404c1766b1a32da/ca1dc/oo.png 680w,\n/static/43d47ebc5efba1607404c1766b1a32da/6f18b/oo.png 886w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>하나의 유저 스레드에 하나의 커널 스레드가 대응하는 모델이다. 동시성을 높여주고, 멀티프로세서 시스템에서는 동시에 여러 스레드를 수행할 수 있도록 해준다. 유저 스레드를 늘리면 커널 스레드도 똑같이 늘어나는데, 커널 스레드를 생성하는 것은 오버헤드가 큰 작업이기 때문에 성능 저하가 발생할 수 있다.</p>\n<h3>Many-to-many model</h3>\n<p align='center'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/7d1b49345f52ede656f009cb4c7d6864/6f18b/mm.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 75.88235294117648%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACeklEQVQ4y61UaVPbMBDN//9HTMlREoYpOBchTgyxJZ+ybJPYOUhIgNddJRyl02/VzI6066cn7e6Ta6+vr9hut3/Z8/Ozse/r78b7397ejPGoPT09wfcDBEGIiCwkC8i/bHdwQdZut1E/b6LVaOD62kIUxYQJDE5KH6vVCu+DSWubzQZxnCBRKYZ+iiBWyJSC5UjYro8kDHH74KPrCMS09uMjLiU8kzOhUolZmxsyITsqSdDxNNwoRUEAy89wF2iztkONG5mhSBUkEXZcjSQ+kiwWCwjPg0u23e4+b5imGpaXwPUj2phiIBXuQ4VFkWMaKNySnxPhvQgMThMmSRSKPIMU0qRfltWRUFCA6yg8gclkCtue4O5ujF63h8FgCMvqYkz+hOLTqQOPbsN19gj/tYYfKYvTCUwqhYBDm5jQuuni19UV+r0+xmMbjuPAl8fDGf9PQk5ZUZE5jYFI4LgSKaUTK41RmEHrzNSM4/zdpEt43jefz7Hb7cBq2e/3n02JqbuaGnNJjZnF2qzDiBrlpvBpZt+jODckpXXEyqBD3dkMD2ST6RT54+MX2SR0Q5JLT2p4IRGwLCjWFcocltGtRMTfjzgmY3vMc8xmriGdL8ojIdckDCMjbgb1+3006iTmnxdoNS/QbLZQbzQp1oCQJywZ72PZLKsllssVpXxA7eXlBRW1uyxLM1dVZeqSZzlyOr0oCmNaa2RkH7jTnsPh8GdT8B/G+1s2T68qFzg7O8OP8zoGwwFGoxF6lDLXxOqS/mwbnmB9TozPxedGsH9D+uRs3knNDflvwUFFRV+v1+Ca8l+EpcAa47RYEvys2OeS8My4ark0UvlK+BsBVFoRTCv51AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mm' title='mm' src='/static/7d1b49345f52ede656f009cb4c7d6864/ca1dc/mm.png' srcset='/static/7d1b49345f52ede656f009cb4c7d6864/e7570/mm.png 170w,\n/static/7d1b49345f52ede656f009cb4c7d6864/f46e7/mm.png 340w,\n/static/7d1b49345f52ede656f009cb4c7d6864/ca1dc/mm.png 680w,\n/static/7d1b49345f52ede656f009cb4c7d6864/6f18b/mm.png 886w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n</p>\n<p>여러 유저 스레드에 더 적거나 같은 수의 커널 스레드가 대응하는 모델이다. 운영체제는 충분한 수의 커널 스레드를 만들 수 있으며, 커널 스레드의 구체적인 개수는 프로그램이나 작동 기기에 따라 다르다. 멀티프로세서 시스템에서는 싱글프로세서 시스템보다 더 많은 커널 스레드가 만들어진다.</p>","frontmatter":{"title":"[운영체제(OS)] 3. 쓰레드(Thread)","date":"March 01, 2022","update":"March 01, 2022","tags":["운영체제"],"series":null},"fields":{"slug":"/thread/","readingTime":{"minutes":8.3}}},"seriesList":{"edges":[{"node":{"id":"aeeabe20-f428-571f-a085-6cb528323517","fields":{"slug":"/jvm/"},"frontmatter":{"title":"Java Virtaul Machine"}}},{"node":{"id":"d322ca1f-aa27-5fc4-8ceb-7982c5738663","fields":{"slug":"/hashing/"},"frontmatter":{"title":"해싱이란?"}}},{"node":{"id":"85f7d472-c933-5918-9df5-33510bbd5c40","fields":{"slug":"/primitive-type/"},"frontmatter":{"title":"기본 타입(primitive type)"}}},{"node":{"id":"bbbb67ac-6c95-5684-b034-0f5e0ddc8ca1","fields":{"slug":"/equals/"},"frontmatter":{"title":"equals와 =="}}},{"node":{"id":"9c040466-1d6f-5b3f-b1e2-b611a0920f53","fields":{"slug":"/stringPool/"},"frontmatter":{"title":"String Pool"}}},{"node":{"id":"e9ec703f-3d62-523a-b7c7-f121c47bbf9f","fields":{"slug":"/string/"},"frontmatter":{"title":"문자열 중복 "}}},{"node":{"id":"c8e0cf33-615a-59be-bc1e-e26c406c927d","fields":{"slug":"/hashmap/"},"frontmatter":{"title":"HashMap"}}},{"node":{"id":"4e14a9fa-fa01-5cbc-9153-9bc68655ca17","fields":{"slug":"/generic/"},"frontmatter":{"title":"제너릭(Generic)"}}},{"node":{"id":"7c769d15-9003-56b7-9fc5-b1b960da36c0","fields":{"slug":"/process/"},"frontmatter":{"title":"[운영체제(OS)] 1.프로세스"}}},{"node":{"id":"4da2182b-2793-5418-a407-01f29fbbd757","fields":{"slug":"/map/"},"frontmatter":{"title":"HashMap, HashTable, ConcurrentHashMap"}}},{"node":{"id":"15a49153-8fff-5ab6-953e-5215b8e2faec","fields":{"slug":"/process2/"},"frontmatter":{"title":"[운영체제(OS)] 2.프로세스-IPC"}}},{"node":{"id":"0e33327d-d671-5b12-aa17-919f5b7107bd","fields":{"slug":"/thread/"},"frontmatter":{"title":"[운영체제(OS)] 3. 쓰레드(Thread)"}}},{"node":{"id":"794b97e8-63d4-5ed3-b203-d391651ec308","fields":{"slug":"/atomic/"},"frontmatter":{"title":"Java - Atomic"}}},{"node":{"id":"e7ea69fe-b48d-530a-9cb3-6cb7afeb7f67","fields":{"slug":"/adder-accumulator/"},"frontmatter":{"title":"Java - LongAdder와 LongAccumulator"}}},{"node":{"id":"678a2cb4-6b30-5113-9297-704160fe3a46","fields":{"slug":"/lambda/"},"frontmatter":{"title":"Java - 람다와 함수형 인터페이스"}}},{"node":{"id":"ea516931-cf7d-5fe6-a5e2-43145feed0e7","fields":{"slug":"/var/"},"frontmatter":{"title":"Java - var"}}},{"node":{"id":"03eac536-09bf-5d35-9903-1e5eff2c7123","fields":{"slug":"/fetch/"},"frontmatter":{"title":"JPA - 즉시로딩과 지연로딩"}}},{"node":{"id":"97f1315c-697a-52a2-ae72-77e3cb4869ec","fields":{"slug":"/content-type/"},"frontmatter":{"title":"[토이 프로젝트] - Content-Type - application/json"}}}]},"previous":{"fields":{"slug":"/process2/"},"frontmatter":{"title":"[운영체제(OS)] 2.프로세스-IPC"}},"next":{"fields":{"slug":"/atomic/"},"frontmatter":{"title":"Java - Atomic"}}},"pageContext":{"id":"0e33327d-d671-5b12-aa17-919f5b7107bd","series":null,"previousPostId":"15a49153-8fff-5ab6-953e-5215b8e2faec","nextPostId":"794b97e8-63d4-5ed3-b203-d391651ec308"}},"staticQueryHashes":[]}